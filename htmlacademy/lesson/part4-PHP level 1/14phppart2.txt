Курс 4. Знакомство с PHP. Часть 2: Массивы и циклы в PHP


Урок 1. 
Урок 2. 

Что такое массивы
Отлично! Список брендов появился на странице.

Блок кода, который мы раскомментировали в предыдущем шаге, называется массивом. Массив — способ хранить несколько значений в одном месте. Например, в прошлом задании массив содержал в себе названия брендов.

['ehm', 'cubic', 'tehnodom', 'dg']
Если записать каждое значение в отдельную переменную, код получится объёмным, особенно если брендов станет больше. Поэтому удобно хранить все значения в одном месте.

Синтаксис массива такой: начало и конец массива обозначаются квадратными скобками, а все значения, или элементы массива, пишутся внутри этих скобок через запятую.

Массив можно записать в переменную, так же как строки и числа.

$название_массива = [элемент_1, элемент_2, элемент_3];
Подробнее о том, какие бывают массивы, и для чего их используют, вы можете почитать в учебнике по PHP.

У Думпо есть гипотеза, которую надо проверить. Нужно вывести на страницу товара product.php список его преимуществ. Думпо считает, это может увеличить количество покупок.

Все преимущества уже находятся в сценарии product.php. Они записаны в массив $features. Попробуем добавить эту переменную в шаблон components/product_info.php и посмотрим, что появится на странице товара.

Урок 3.  

Индексы элементов массива
Мы добавили массив в шаблон привычным способом, как любую переменную. Но этот способ не сработал — преимущества товара не вывелись на страницу. Сейчас разберёмся почему и как это исправить.

Преимущества не появились, потому что мы попытались вывести весь массив целиком. Когда PHP просят вывести переменную-массив, он не знает, как это сделать, поэтому вместо её содержания просто пишет, что это массив, то есть Array по-английски. Поэтому вместо преимуществ и ввелось это слово.

Чтобы преимущества появились на странице, нужно выводить не сам массив, а его элементы. Для этого нужно использовать индексы.

Все элементы в массиве имеют порядковый номер, то есть индекс. Он позволяет получить доступ к какому-то конкретному элементу массива.

Возьмём массив с фильмами студии Marvel.

$films = ['Железный человек', 'Мстители', 'Тор', 'Человек-муравей'];
Добавляем на страницу название первого фильма.

<p><?= $films[0] ?></p>  // Выведет на страницу: Железный человек
Чтобы получить доступ к элементу массива, нужно написать имя массива и индекс элемента в квадратных скобках. Нумерация элементов в массиве начинается с нуля. Поэтому, чтобы вывести на страницу первый фильм из массива $films, мы написали $films[0].

Добавим на страницу второй фильм:

<p><?= $films[1] ?></p>  // Выведет на с


Урок 4.

Добавляем элемент в массив по индексу
Маркетологи попросили добавить ещё несколько преимуществ в массив. Мы могли бы сделать это вручную, то есть добавить новые элементы через запятые прямо в массив. Но попробуем другой способ — добавление с помощью индексов. Они позволяют не только получать элементы, но и записывать в массив новые данные.

Например, у нас есть массив с любимой едой. В нём всего три элемента, то есть индекс последнего элемента 2. Добавим в этот массив ещё один элемент.

$favorite_food = ['пюре', 'котлеты', 'борщ'];
$favorite_food[3] = 'пельмени';
keks_log($favorite_food[3]);    // Выведет: "пельмени"
В массиве не было элемента с индексом 3. Мы обратились к этому элементу и задали ему значение. После этого он сохранился в массив.

Если бы мы обратились к элементу, который уже был в массиве, изменилось бы его значение.

$favorite_food = ['пюре', 'котлеты', 'борщ'];
keks_log($favorite_food[1]);    // Выведет: "котлеты"
$favorite_food[1] = 'блины';     
keks_log($favorite_food[1]);    // Выведет: "блины"
Попробуем с помощью индексов записать 


Урок 5. 

Цикл while в PHP
Почему на страницу не вывелось преимущество с индексом 3? Потому что в шаблон мы добавляем элементы с конкретными индексами — 0, 1, 2. Там нет обращения к четвёртому элементу. Выходит неудобно — чтобы выводить все элементы массива, нужно следить за изменениями внутри этого массива и вручную обращаться к каждому элементу по очереди.

Думпо уже вручную добавил в $features все новые преимущества от маркетологов. Давайте автоматизируем их добавление на страницу, чтобы избавить себя от однообразной работы. С этим нам поможет цикл.

Цикл — конструкция, которая позволяет выполнить один и тот же код больше одного раза. Например, вывести элементы из массива на страницу.

Существуют разные циклы, начнём знакомство с цикла while.

while (условие цикла) {
  тело цикла
}
Синтаксис цикла while похож на синтаксис условной конструкции — он состоит из имени цикла, условия цикла и тела цикла. Действия, указанные в теле цикла, будут выполняться снова и снова, пока условие не станет ложным.

Циклы отлично работают с массивами. Возьмём, к примеру, массив $months с числами от 1 до 12.

$months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
Чтобы вывести в консоль все значения из этого массива, используем цикл while:

$index = 0;                  // Создание счётчика

while ($index < 12) {
  keks_log($months[$index]);  // Вывод элемента в консоль
  $index = $index + 1;       // Увеличение счётчика
}
Каждое выполнение блока кода в теле цикла называется итерацией. Количество итераций должно быть конечным, иначе цикл будет исполняться бесконечное число раз, и страница может загружаться бесконечно долго.

Чтобы ограничить количество итераций, мы создали переменную-счётчик $index. С каждой итерацией число в $index будет увеличиваться на единицу. В итоге в консоль по очереди выведутся элементы массива $months — числа от 1 до 12. Когда значение счётчика достигнет 12, условие станет ложным и цикл прекратит свою работу.

Почему $index должен быть меньше 12? Потому что индекс последнего элемента в массиве — 11. Элемента с индексом 12 нет.

Дополнительную информацию о циклах вы можете почерпнуть из учебника по PHP.

Напишем цикл while в сценарии product.php. В теле цикла выведем каждый элемент массива $features в консоль.


https://htmlacademy.ru/tutorial/php/syntax#Конкатенация
https://htmlacademy.ru/tutorial/php/arrays
https://htmlacademy.ru/tutorial/php/loops

Урок 6. 

Внедряем цикл while в шаблон
Мы разобрались с циклом while. Теперь внедрим его в шаблон components/product_info.php, чтобы на странице товара появились все преимущества из массива $features.

Для этого обозначим в шаблоне начало и конец цикла. Затем запишем условие и зададим увеличение индекса элемента с каждой итерацией.

<?php while (условие): ?>       // Начало цикла

<?php $index = $index + 1 ?>    // Увеличение индекса
<?php endwhile; ?>              // Конец цикла
И наконец, в тело цикла добавим вывод преимуществ из массива в список.

<?php while (условие): ?>
<li><?= $массив[$index] ?></li>
<?php $index = $index + 1 ?>
<?php endwhile; ?>
В шаблоне весь код между началом и концом цикла будет выполняться определённое количество раз, пока цикл не прекратит свою работу. Если в теле цикла разметка, она будет добавляться на страницу с каждой итерацией в дополнение к той разметке, что уже вывелась на предыдущей итерации. Если в цикле PHP-код, он будет выполняться на каждой итерации, а не один раз.

Внедрим в шаблон components/product_info.php цикл while и выведем на страницу все преимущества товара. Не забудем использовать PHP-теги. Думпо уже поправил наш код в шаблоне, удалил вывод второго и третьего преимуществ и создал переменную-счётчик $index.



Урок 7. 

Считаем количество элементов в массиве: команда count
Маркетологи неожиданно решили увеличить количество преимуществ у товара и прислали список элементов, которые нужно добавить в массив.

На предыдущем шаге мы сами посчитали количество элементов в массиве и записали это число в условие $index < 6. После добавления новых преимуществ количество элементов изменится. Но мы же не будем каждый раз, когда массив меняется, считать самостоятельно число элементов и править условие?

Для автоматического подсчёта элементов в массиве, или длины массива, существует команда count.

Возьмём массив чисел:

$numbers = [1, 2, 3, 4, 5];
Посчитаем длину этого массива. Для этого нужно после слова count написать круглые скобки, а внутри скобок — название массива. А чтобы мы могли дальше работать с полученным значением, сохраним его в переменную.

$numbers_quantity = count($numbers);
keks_log($numbers_quantity); // Выведет: 5
Переменная $numbers_quantity будет равна 5. То есть в массиве $numbers всего пять элементов.

При этом нужно помнить, что команда count считает именно количество элементов, а не их индексы. Индекс последнего элемента в массиве $numbers равен 4, а не 5.

Давайте проверим работу этой команды на практике: посчитаем число элементов в $features и выведем результат в консоль. А затем порадуем маркетологов и добавим преимущества в массив. Проверим, как изменится длина массива.



Урок 8. 

Закрыть
Добавляем count в шаблон
Отлично! Теперь мы знаем, как получить длину массива с помощью команды count.

Добавим count($features) прямо в условие цикла в шаблоне. Проверим, что при любой длине массива на странице будут отображаться все преимущества товара из этого массива.

Может показаться, что использовать команду прямо в условии цикла не очень рационально. Ведь на каждой итерации она будет снова срабатывать и считать длину массива. Не проще было бы сохранить длину массива в переменную и уже её использовать в шаблоне? Можно и так, но подобные процессы уже хорошо оптимизированы в PHP. Если массив не состоит из тысяч элементов, проблем с производительностью не будет.

Добавим команду count в шаблон и сами в этом убедимся!



Урок 9. 

Выводим элементы из массива по id
Мы научились выводить элементы из массивов разной длины на страницу. Проверим, что наш код универсален и сработает с любым товаром интернет-магазина.

В базе данных у каждого товара есть преимущества. Чтобы их получить, нужно использовать команду get_product_features и в скобках указать идентификатор товара.

База данных уже подключена в сценарии product.php. Заменим значение $features на вызов команды get_product_features. Поменяем номера товаров в адресной строке и посмотрим, как отобразятся преимущества на странице.

После этого можно отдавать Думпо готовую задачу!


Урок 10. 

Ассоциативный массив в PHP
А вот и новая задача. В каталоге должна появиться фильтрация товаров по категориям. При клике на любую из них, на странице должны появляться товары только выбранной категории.

Начнём работать над задачей постепенно. Сначала научимся добавлять один товар на страницу.

Разработчики подготовили для нас массив $item. В нём хранится разная информация о товаре — название, цена, фотография и категория. Только вместо индекса у каждого элемента есть своё название, или ключ.

Массив, у которого вместо индексов ключи, называется ассоциативным. Каждый ключ хранит какое-то значение, как переменная. Имя ключа пишется в одинарных кавычках, а чтобы задать ключу значение, используются символы =>.

$spiderman = [
  'name' => 'Питер',    // Ключ 'name', значение 'Питер'
  'surname' => 'Паркер' // Ключ 'surname', значение 'Паркер'
];
Оба элемента массива из примера относятся к Человеку-пауку, поэтому удобно хранить их не по отдельности в переменных, а вместе, в одном массиве.

Чтобы получить значение из такого массива, нужно написать название массива, а затем в квадратных скобках указать ключ.

keks_log($spiderman['name']);    // Выведет: "Питер"
keks_log($spiderman['surname']); // Выведет: "Паркер"
В шаблоне components/product_list.php добавим в карточку товара название, цену и фотографию товара. Для этого будем обращаться к ключам массива $item.

Больше про массивы и примеры их использования на сайтах можно узнать в этой статье из блога HTML Academy.

А ещё об ассоциативных массивах можно почитать в учебнике по PHP.


https://htmlacademy.ru/blog/boost/frontend/associative-arrays-php
https://htmlacademy.ru/tutorial/php/arrays#Ассоциативные-массивы



Урок 11. 

Цикл foreach в PHP
Разработчики добавили в массив $item ещё один массив $colors, в котором хранятся цвета товара. Да, элементами массива могут быть и другие массивы. Они называются вложенными.

Наша задача — доработать отрисовку карточки товара, чтобы на странице появились все цвета из массива $colors.

Мы уже знаем, как выводить на страницу элементы массива с помощью цикла while. Этот цикл не очень удобен: нужно придумывать условие, создавать счётчик и следить за тем, чтобы цикл не был бесконечным. Есть другой цикл, в котором всё это не нужно — foreach.

foreach ($массив as $переменная) {
  тело цикла
}
На каждой итерации значением переменной становится очередной элемент массива. Элементы перебираются по порядку с первого до последнего. Поэтому нам не нужны индексы, достаточно обратиться в теле цикла к переменной.

Чтобы добавить такой цикл в разметку, нужно записать его начало и конец, а в тело цикла поместить действия с разметкой.

$fruits = ['Апельсин', 'Яблоко', 'Банан'];

<?php foreach ($fruits as $fruit): ?>
<li><?= $fruit ?></li>
<?php endforeach; ?>
// На странице появится список фруктов
Подробнее о том, как устроен цикл foreach, можно почитать в учебнике по PHP.

Выведем цвета товара в шаблон с помощью цикла foreach. Верстальщики подготовили разметку и стили для списка цветов. Каждому цвету соответствует тег <li> с особым классом. Для каждого цвета нам нужно добавить отдельный <li> в разметку и задать этому элементу нужный класс. Тогда доступные цвета товара появятся на странице. Проверим




https://htmlacademy.ru/tutorial/php/loops#foreach---специальный-цикл-для-массивов



Урок 12. 

Выводим элементы массива на страницу с помощью foreach
Мы научились добавлять один товар на страницу, но в каталоге их обычно больше. Потренируемся выводить несколько товаров. Думпо уже поправил название массива $item на $items и добавил в него данные о разных товарах.

Каждый элемент массива $items — ассоциативный массив с данными одного товара. Нам нужно вывести данные из каждого такого массива на страницу. Рассмотрим эту задачу на примере:

$flowers = [
  0 => [
    'name' => 'Ромашка',
    'cost' => 'free'
  ],
  1 => [
    'name' => 'Лилия',
    'cost' => 300
  ]
];
Воспользуемся циклом foreach. В круглых скобках цикла напишем уже знакомое:

<?php foreach ($flowers as $flower): ?>

<?php endforeach;?>
Теперь массивы внутри $flowers по очереди на каждой итерации будут записываться в переменную $flower.

Чтобы вывести на страницу название цветка из каждого массива, на каждой итерации нужно обращаться к ключу 'name'.

<?php foreach ($flowers as $flower): ?>
<p><?= $flower['name'] ?></p>
<?php endforeach;?>
На странице появятся два абзаца — по количеству элементов в массиве $flowers:

<p>Ромашка</p>
<p>Лилия</p>
Добавим в шаблон components/products_list.php цикл foreach и с его помощью выведем на страницу все товары из массива $items.



Урок 13. 

Подключаем базу данных
Отлично! Мы научились отображать карточки товара на странице. До этого мы работали с временными данными из массива $items, но ведь у нас есть база c настоящими данными. Пора бы взять информацию оттуда.

Подключим базу данных products_db.php в сценарий catalog.php. Вместо массива запишем в переменную $items команду get_products — так мы получим массив со всеми товарами из базы. Убедимся, что наш код по-прежнему работает и товары добавляются на страницу.

Приступим.




Урок 14. 

Закрыть
Фильтруем товары
Мы научились добавлять товары из массива на страницу. Теперь мы готовы приступить к фильтрации. Разработчики уже добавили фильтры в сценарий catalog.php и в шаблон components/products_list.php.

Наша задача — дополнить цикл, который отображает карточки на странице, так, чтобы на страницу добавлялись не все товары из массива, а только товары выбранной категории. Например, пользователь выбирает фильтр «Мебель» и на странице появляются товары только такого типа.

Как это реализовать? Для начала надо выяснить, какой фильтр сейчас выбран. У каждого фильтра есть свой адрес с параметром запроса product_type:

catalog.php?product_type=furniture
Чтобы определить, какой фильтр выбрал пользователь, достаточно получить значение параметра запроса с помощью уже знакомой нам команды $_GET.

Старшие разработчики уже создали переменную $type со значением $_GET['product_type'] в сценарии.

Хорошо, мы знаем активный фильтр. Как теперь найти товары подходящей категории в массиве? Разработчики позаботились и об этом.

У каждого товара в массиве $items есть ключ 'type'. Это и есть категория товара.

[
  'title' => 'Подвесная кровать Асусмер',
  'type' => 'furniture',
  'colors' => ['blue']
]
Нам достаточно внутри нашего цикла foreach сравнить активный фильтр из $type со значением 'type' каждого товара в массиве. Если они совпадают, проверка пройдёт и товар появится на странице.

Для сравнения будем использовать условие. В круглых скобках запишем:

$item['type'] === $type
Будем использовать оператор сравнения ===. Он называется строгое равенство и проверяет, равны ли значения слева и справа. Если равны, то условие истинно.

Давайте попробуем всё это на практике.

Урок 15. 

Выводим все товары на страницу
Сейчас мы сравниваем тип товара и значение параметра запроса product_type. Если они совпадают, мы выводим на страницу этот товар.

Это работает, потому что почти на каждое значение product_type есть такой же тип товара в массиве $items.

Почему почти? У категории «Все товары» значение параметра all. Такого типа товара у нас нет, поэтому сейчас мы не можем увидеть сразу все товары в каталоге по такому адресу:

catalog.php?product_type=all
Доработаем условие так, чтобы при нажатии на «Все товары» на странице появлялись все товары из массива $items, независимо от их типа.

Воспользуемся логическим оператором ИЛИ, мы работали с ним в части «Условия в PHP».

$item['type'] === $type || $type === 'all'
Дополним условие и убедимся, что все товары добавляются в каталог при выборе фильтра «Все товары». Остался последний штрих, не будем медлить.


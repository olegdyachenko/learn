Курс 4. Знакомство с PHP. Часть 3: Массивы и функции в PHP


Урок 1. 
Закрыть
Выводим на страницу все товары из заказа
Вместе с командой Думпо мы продолжаем работу над интернет-магазином. Мы отлично потрудились в стартовом тренажёре и прошлых частях текущего тренажёра, но некоторые страницы ещё требуют доработки. Например, страница доставки.

В части про условия мы рассчитали и вывели на страницу итоговую цену и стоимость доставки одного товара. Но в заказе может быть несколько товаров. В этом случае нужно показать информацию о каждом из них.

В массиве $order записаны идентификаторы товаров, которые содержатся в заказе.

$order = [2, 7, 15, 16];
С помощью цикла foreach выведем на страницу доставки все товары из массива $order.

<?php foreach($order as $id): ?>
  ...
<?php endforeach; ?>
Мы уже работали с массивами и циклами в прошлой части.


Урок 2. 
Закрыть
Выводим на страницу все товары из заказа
Вместе с командой Думпо мы продолжаем работу над интернет-магазином. Мы отлично потрудились в стартовом тренажёре и прошлых частях текущего тренажёра, но некоторые страницы ещё требуют доработки. Например, страница доставки.

В части про условия мы рассчитали и вывели на страницу итоговую цену и стоимость доставки одного товара. Но в заказе может быть несколько товаров. В этом случае нужно показать информацию о каждом из них.

В массиве $order записаны идентификаторы товаров, которые содержатся в заказе.

$order = [2, 7, 15, 16];
С помощью цикла foreach выведем на страницу доставки все товары из массива $order.

<?php foreach($order as $id): ?>
  ...
<?php endforeach; ?>
Мы уже работали с массивами и циклами в прошлой части.


Урок 3.  

Аргументы функции
Мы объявили функцию и научились вызывать её. Но пока наша функция не очень полезна — она просто выводит в консоль одну и ту же фразу. Как сделать так, чтобы функция выводила итоговую цену товара, причём для каждого товара — свою?

Используем аргументы функции. Они позволяют передавать функции разные данные и влиять на результат её работы.

Аргументы указывают в круглых скобках при объявлении функции. Аргументов может быть сколько угодно. Если их несколько, они указываются через запятую.

Аргументы похожи на переменные. Они тоже хранят значения, и их имена должны начинаться со знака доллара. Аргументы можно использовать только в теле функции:

function my_func($number_1, $number_2) {
  keks_log($number_1 - $number_2);
}
Функция в примере принимает два аргумента, вычитает второй аргумент из первого и выводит результат в консоль. Но как она узнает, какие числа использовать? Для этого функции надо передать значения аргументов.

Значения аргументов указывают в круглых скобках при вызове функции. Их перечисляют через запятую в том же порядке, что и аргументы при объявлении функции.

my_func(3, 1); // Выведет: "2"
my_func(1, 3); // Выведет: "-2"
Подробнее о том, как устроены функции, вы можете почитать в учебнике по PHP.

Нам нужно посчитать итоговую цену товара. Чтобы её получить, надо из полной цены вычесть скидку. Укажем, что функция get_final_price принимает два аргумента: $price и $discount — и выводит в консоль их разницу. После этого вызовем функцию, передав ей разные значения.

https://htmlacademy.ru/tutorial/php/functions


Урок 4. 

Функция возвращает значение
Мы научились передавать функции аргументы, считать итоговую цену товара и выводить её в консоль. Но что будет, если вызвать функцию get_final_price в шаблоне?

<td><?= get_final_price(1000, 200) ?></td>
В консоли появятся новые сообщения, но в мини-браузере итоговая цена не отобразится, потому что команда keks_log выводит сообщение в консоль, но не на страницу. Чтобы итоговая цена появилась на странице, функция get_final_price должна её вернуть.

Функции могут не только принимать данные, но и возвращать их. Представьте, что мы задаём функции вопрос, а она на него отвечает. Чтобы указать, что именно функция должна ответить, или какое значение вернуть, используют ключевое слово return:

function my_func($number_1, $number_2) {
  return $number_1 - $number_2;
}
Когда функцию вызовут, на её место в коде подставится то значение, которое она вернёт:

<!-- Вызываем функцию в шаблоне -->
<p><?= my_func(3, 1) ?></p>

<!-- Результат  -->
<p>2</p>
Вернув значение, функция прекратит работу. Последующий код в теле функции PHP проигнорирует.

function my_func($number_1, $number_2) {
  return $number_1 - $number_2;

  // Код на следующей строке никогда не будет исполнен
  keks_log('Есть ли жизнь после return?');
}
Функция может ничего не возвращать или вернуть одно любое значение: число, строку, массив и так далее.

Итак, нам нужно вывести на страницу итоговую цену товара. Укажем, что функция get_final_price возвращает разницу между полной ценой и скидкой на товар. После этого вызовем функцию в шаблоне components/delivery_info.php. Используем для вставки PHP-кода краткую запись:

<?= my_func(3, 1) ?>


Урок 5. 

ередаём функции идентификатор товара
Мы создали функцию, которая возвращает итоговую цену, и вызвали её в шаблоне. В результате у всех товаров на странице снова отобразилась одна и та же цена. Мы зря создавали функцию? Ничего подобного. Чтобы показать правильную цену для каждого товара, осталось лишь передать функции правильные данные.

До этого мы вручную передавали функции полную цену и скидку на товар, но мы можем сказать функции самой получать их из базы данных. Используем специальные команды, чтобы узнать цену и скидку на конкретный товар:

get_product_price ($id) — цена;
get_product_discount ($id) — скидка.
Для обеих команд нужен идентификатор товара. Укажем, что функция get_final_price принимает его как аргумент. Другие аргументы больше не понадобятся:

function get_final_price($id) {
  ...
}
В теле функции узнаем цену и скидку на товар, чей идентификатор мы получили. Сохраним их в переменные:

$price = get_product_price($id);
$discount = get_product_discount($id);
Функция по-прежнему будет возвращать разницу между $price и $discount, но теперь их значения будут браться из базы данных, а не из аргументов.

Идентификаторы товаров хранятся в массиве $order. С помощью foreach в шаблоне мы получаем новый идентификатор на каждой итерации цикла.

<?php foreach($order as $id): ?>
Вызовем функцию get_final_price внутри цикла и передадим ей в качестве аргумента идентификатор товара. На каждой итерации цикла функция будет вызываться заново, с новым идентификатором. В результате для разных товаров выведется разная итоговая цена.

Вы заметили, что использование команд из базы данных очень похоже на вызовы функций? Это они и есть. Команды get_product_price и get_product_discount — самые обычные функции, просто написанные другими разработчиками.

Переменные, объявленные внутри функции, доступны только внутри этой функции. А внешние переменные, наоборот, внутри функции не видны. Это называется областью видимости. Вы можете узнать о ней больше в документации.

https://www.php.net/manual/ru/language.variables.scope.php




Урок 6. 

Вычисляем стоимость доставки
С помощью функции get_final_price мы посчитали итоговую стоимость для каждого товара в заказе. Теперь вычислим для каждого товара стоимость доставки.

Стоимость мы уже считали в одной из прошлых частей. Думпо скопировал наши старые вычисления и добавил их в сценарий.

// Получаем данные о товаре
$price = get_product_price($id);
$discount = get_product_discount($id);
$is_new = get_product_is_new($id);
$final_price = $price - $discount;

// Стоимость доставки зависит от итоговой цены и новизны товара
if ($is_new && $final_price < 2000) {
  $delivery_cost = $final_price;
} else {
  $delivery_cost = $final_price / 20;
}
Используем функцию, чтобы вывести на страницу стоимость доставки для каждого товара в заказе. Действовать будем по аналогии с итоговой ценой.

Создадим функцию get_delivery_cost, которая принимает идентификатор товара и возвращает стоимость его доставки. Переместим вычисления в тело функции, после чего вызовем её в шаблоне.

Урок 7.

Оптимизируем функцию
Мы создали функцию, которая считает стоимость доставки товара. Функция работает, но код получился избыточным и негибким. Посмотрим, почему так вышло.

Стоимость доставки зависит от итоговой цены. Чтобы получить её внутри функции get_delivery_cost, мы снова берём данные из базы и вычитаем скидку из полной цены товара. Но ведь для этого уже есть функция get_final_price! Лучше использовать её. В таком случае, если изменится формула, править вычисления придётся только в одном месте.

Сделаем наш код универсальным. Вызовем функцию get_final_price внутри функции get_delivery_cost, чтобы получить итоговую цену товара. После этого убедимся, что если изменить формулу итоговой цены, то стоимость доставки пересчитается автоматически.

Мы можем вызывать одну функцию внутри другой. Но что случится, если в теле одной функции объявить другую функцию? Это не будет ошибкой, но «внутреннюю» функцию можно будет вызвать только после того, как вызовут «внешнюю».

Урок 8. 

Закрыть
Встроенные функции
Мы отлично справились со страницей доставки, поэтому Думпо доверил нам работу с главной страницей интернет-магазина. На ней нужно показать карточки с тремя случайными промо-товарами. Промо-товарами считаются все новые товары и пять самых дешёвых.

Подвесная кровать Асусмер
10000₽
Подвесная кровать Асусмер
Диван Рмаериби
15000₽
Диван Рмаериби
Компакт-кассета Преум
200₽
Компакт-кассета Преум
Думпо уже написал код, который выводит на страницу карточки со всеми товарами. Этот код находится в шаблоне components/promo.php. Чтобы карточки с товарами появились на главной странице, этот шаблон туда нужно подключить.

Мы уже подключали файлы с помощью команды require:

require('file.php');
Чтобы подключить файл, мы писали название команды, а затем в круглых скобках указывали адрес файла. Похоже на вызов функции и передачу ей аргумента, не правда ли? Так и есть. Команда require — это функция. Но мы её не объявляли и это не разработка студии Кекса, так откуда она взялась? Прямо из PHP. Это встроенная функция.

Встроенные функции — это функции, которые написали создатели PHP. Это часть языка, поэтому их не нужно объявлять, прежде чем использовать. В PHP существуют тысячи готовых функций. Нет нужды заучивать их наизусть, ведь всегда можно заглянуть в документацию.

В прошлой части мы работали с командой count. Это тоже встроенная функция, она принимает массив в качестве аргумента и возвращает его длину. В PHP есть множество встроенных функций для работы с массивами. Некоторые из них понадобятся нам, чтобы выполнить задачу и вывести на страницу карточки со случайными промо-товарами.

Но сначала подключим шаблон components/promo.php к главной странице интернет-магазина.

https://www.php.net/manual/ru/funcref.php
https://www.php.net/manual/ru/ref.array.php


Урок 9. 
Функция uasort, сортируем товары
С помощью встроенной функции require мы подключили на главную страницу шаблон с карточками товаров. Сейчас на странице показываются все товары, но заказчик хочет, чтобы показывались только три случайных промо-товара.

К промо-товарам относятся все новые товары и пять самых дешёвых. Нам предстоит сформировать массив с промо-товарами и изменить шаблон так, чтобы на странице показывались три случайных элемента из этого массива.

Все товары хранятся в массиве $products. Это ассоциативный массив, ключами которого служат идентификаторы товаров, а значениями — сами товары.

Начнём с поиска самых дешёвых товаров. Каждый товар также является ассоциативным массивом. За цену отвечает ключ 'price':

'6' => [
  'title' => 'Лампа Мсеюлида',
  'img_url' => 'img/item-mseyulida.jpg',
  'price' => 4000,
  'is_new' => false
]
Чтобы найти самые дешёвые товары, отсортируем все товары по цене. Сортировка — непростая задача, но, к счастью, для неё в PHP есть встроенная функция uasort.

Эта функция принимает два аргумента. Первый — массив, который нужно отсортировать. Второй — имя функции, которая говорит, как именно нужно сортировать. В следующем задании мы подробно разберём, что это за функция.

uasort($array, 'function_name');
Отсортируем товары, вызвав встроенную функцию uasort. Передадим ей массив $products и функцию sort_by_price.

Функций сортировки в PHP несколько. О различиях между ними можно почитать в документации.

https://www.php.net/manual/ru/array.sorting.php

Урок 10. 

Закрыть
Меняем направление сортировки
Мы отсортировали массив с помощью встроенной функции uasort. При этом мы передали ей функцию sort_by_price. Что это за функция?

Это колбэк. Так называют функцию, которая передаётся в качестве аргумента другой функции. Колбэки не являются встроенными функциями, их пишут сами разработчики. Посмотрим, как устроена функция sort_by_price.

В качестве аргументов она принимает два товара, сравнивает цены этих товаров и возвращает число: 1, -1 или 0.

function sort_by_price($product_1, $product_2) {
  // Если цена первого товара больше, результат - положительное число
  if ($product_1['price'] > $product_2['price']) {
    $result = 1;
  }

  // Если цена первого товара меньше, результат - отрицательное число
  if ($product_1['price'] < $product_2['price']) {
    $result = -1;
  }

  // Если цены равны, результат равен нулю
  if ($product_1['price'] === $product_2['price']) {
    $result = 0;
  }

  return $result;
}
Почему мы использовали именно такой колбэк? Потому что так предписывает документация PHP. Функция-колбэк, которую передают uasort, должна принимать два аргумента и возвращать число: положительное число, если первый аргумент больше, отрицательное число, если больше второй аргумент, и ноль, если аргументы равны. Имя колбэка, имена его аргументов и код в теле функции могут быть любыми.

Во время вызова функция uasort передаёт в колбэк попарно элементы массива, узнаёт, какой из них больше, и сортирует массив по возрастанию: от меньшего к большему.

Так как мы сортируем товары по цене, то используем в колбэке ключ 'price'. Таким образом мы сообщаем функции uasort, что большим нужно считать тот товар, у которого цена выше.

Мы отсортировали товары от самых дешёвых к самым дорогим. Попробуем сделать наоборот — отсортировать товары от самых дорогих к самым дешёвым. Чтобы изменить направление сортировки, скажем функции uasort, что большим нужно считать тот товар, цена которого ниже.

В этом случае функция sort_by_price должна возвращать положительное число, если первый товар дешевле, и отрицательное, если первый товар дороже. Для этого достаточно поменять местами 1 и -1.

// Если цена первого товара больше, результат - отрицательное число
if ($product_1['price'] > $product_2['price']) {
  $result = -1;
}

// Если цена первого товара меньше, результат - положительное число
if ($product_1['price'] < $product_2['price']) {
  $result = 1;
}
Положительные и отрицательные числа, которые возвращает колбэк, не обязательно должны быть 1 и -1. Это могут быть любые целые числа в диапазоне от -2147483648 до 2147483647.

Но если элементы, которые сравниваются, равны, колбэк должен вернуть именно ноль.



ВАЖНЫЙ КОММЕНТАРИЙ ДЛЯ МЕНЯ. КОЛБЕКИ ПИШУТ САМИ РАЗРАБОТЧИКИ

т.е. у нас есть функция сортировки. Она попарно передает два продукта, и система их сравнивает. Очень интересно, но слабо понятно. 
  uasort($products, 'sort_by_price');
  
  и для ее работы мы написали вот это

  function sort_by_price($product_1, $product_2) {
  if ($product_1['price'] > $product_2['price']) {
    $result = 1;
  }

  if ($product_1['price'] < $product_2['price']) {
    $result = -1;
  }

  if ($product_1['price'] === $product_2['price']) {
    $result = 0;
  }

  return $result;
}


Урок 11. 

Закрыть
Функция array_slice, получаем часть массива
Мы отсортировали товары от самых дорогих к самым дешёвым. Покупатели были в ужасе от цен, поэтому Думпо вернул предыдущий вариант сортировки: от дешёвых к дорогим.

Продолжим работу над промо-товарами. К ним относятся пять самых дешёвых товаров из каталога. Чтобы их получить, используем ещё одну встроенную функцию — array_slice. Она принимает массив, копирует его часть и возвращает её в виде нового массива. Массив, который передали функции, при этом не изменяется.

Всего функция array_slice принимает четыре аргумента:

исходный массив,
порядковый номер элемента, с которого начнётся копирование,
количество элементов, которые нужно скопировать,
булево значение — нужно ли сохранять ключи исходного массива.
$new_array = array_slice($array, $first_element, $length, $preserve_keys);
Посмотрим, как работает функция array_slice:

$array = [
  0 => 'ноль',
  1 => 'один',
  2 => 'два',
  3 => 'три',
  4 => 'четыре',
  5 => 'пять'
];

// Скопируем 3 элемента, начиная со второго
$with_keys = array_slice($array, 1, 3, true);     // Сохраняем ключи
$without_keys = array_slice($array, 1, 3, false); // Не сохраняем ключи

// $with_keys – ключи сохранились:
[
  1 => 'один',
  2 => 'два',
  3 => 'три'
];

// $without_keys – ключи не сохранились:
[
  0 => 'один',
  1 => 'два',
  2 => 'три'
];
Товары в массиве $products уже отсортированы от самых дешёвых к самым дорогим. Чтобы получить пять самых дешёвых товаров, передадим функции array_slice такие аргументы:

исходный массив — $products,
первый элемент — 0,
длина нового массива — 5,
сохранять ли ключи — true, ведь в нашем случае ключ — это идентификатор товара, он нужен, чтобы показать правильную информацию о товаре.
Создадим новый массив с пятью самыми дешёвыми товарами и выведем эти товары на страницу.

По умолчанию индексы в массиве начинаются с нуля и идут по порядку. Но это можно изменить, задав индекс вручную.

$months = [1 => 'Январь', 5 => 'Май'];
// $months:
[
  1 => 'Январь',
  5 => 'Май'
]


Урок 12. 

Определяем новизну товара
Мы получили массив из пяти самых дешёвых товаров. Он нужен, чтобы вывести на главную страницу карточки с промо-товарами. К промо-товарам также относятся все новые товары. Чтобы получить их, отфильтруем массив $products. В прошлой части мы уже делали фильтрацию товаров. Тогда мы использовали цикл и условие. Попробуем в этот раз использовать функции.

В PHP есть встроенная функция фильтрации — array_filter. Она принимает два аргумента: исходный массив и функцию-колбэк — и возвращает новый массив. Исходный массив при этом не изменяется.

$filtered_array = array_filter($array, 'callback');
Начнём с колбэка. Согласно документации, он должен принимать элемент исходного массива и возвращать булево значение: true, если этот элемент нужно включить в новый массив, и false, если не нужно.

В новый массив должны попасть все новые товары. У каждого товара есть ключ 'is_new'. Он имеет булево значение: true, если товар новый, и false, если нет:

'2' => [
  'title' => 'Кресло Бадета',
  'img_url' => 'img/item-badeta.jpg',
  'price' => 3500,
  'is_new' => false
],
'7' => [
  'title' => 'Диван Рмаериби',
  'img_url' => 'img/item-rmaeribi-new.jpg',
  'price' => 15000,
  'is_new' => true
]
Получается, ключ 'is_new' содержит именно то значение, которое должна возвращать функция-колбэк. Используем это. Создадим функцию, которая принимает товар и возвращает значение его ключа 'is_new'. С помощью консоли убедимся, что функция работает.

Не стоит путать фильтрацию и сортировку. Фильтрация отвечает за то, какие элементы выводятся, а сортировка — за то, в каком порядке они выводятся.

function filter_new($product){
  return $product['is_new'];
  }
  
keks_log(filter_new($products['7']));



Урок 13. 

Закрыть
Функция array_filter, фильтруем массив
Мы создали функцию, которая принимает товар и определяет, новый ли он. Используем эту функцию, чтобы отфильтровать массив с товарами.

Для этого передадим функцию filter_new в качестве аргумента функции array_filter. Сохраним полученный массив в переменную и используем её, чтобы вывести на страницу новые товары из каталога.

Как правило, встроенные функции максимально оптимизированы. Например, фильтрация с помощью array_filter сработает быстрее, чем фильтрация с помощью цикла.


Урок 14. 

Объединяем массивы
С помощью функции фильтрации мы создали массив с новыми товарами. Чуть раньше мы создали массив с самыми дешёвыми товарами. Пока на странице показывались товары либо из одного массива, либо из другого. Но нам нужно показать промо-товары, к которым относятся и дешёвые товары, и новые. Как это сделать? Объединим два массива.

В PHP массивы можно объединить с помощью знака плюс:

$big_array = $array_1 + $array_2;
В результате получится один массив, который включает элементы как из первого, так и из второго массива. При этом порядок элементов и их ключи сохранятся. Если у нескольких элементов окажутся одинаковые ключи, то значение возьмётся из того массива, который идёт раньше.

$keks = [
  'имя' => 'Кекс',
  'возраст' => 8
];

$dumpo = [
 'имя' => 'Думпо',
  'любимая еда' => 'пельмени'
];

$keks_and_dumpo = $keks + $dumpo;

// $keks_and_dumpo:
[
  'имя' => 'Кекс',
  'возраст' => 8,
  'любимая еда' => 'пельмени'
];
Перед объединением убедитесь, что ключи в массивах не совпадают или что одинаковым ключам соответствуют одинаковые значения.

Нам нужно получить массив с промо-товарами. Для этого объединим массивы $cheap_products и $new_products. Затем выведем все промо-товары на страницу.


Урок 15. 

Закрыть
Функция array_rand, получаем случайные элементы
Мы создали массив с промо-товарами и вывели их на страницу. Но нам нужно показывать не все промо-товары сразу, а только три случайных. Как их выбрать?

Используем встроенную функцию array_rand. Она принимает исходный массив и количество случайных элементов, которые мы хотим получить.

$random = array_rand($array, $number_of_elements);
Если второй аргумент — единица, функция вернёт один случайный ключ. Если второй аргумент больше единицы, функция вернёт массив со случайными ключами.

$array = [
  0 => 'ноль',
  1 => 'один',
  2 => 'два',
  3 => 'три',
  4 => 'четыре',
  5 => 'пять'
];

// Получаем один случайный элемент
$random_element = array_rand($array, 1);
keks_log($random_element); // Выведет (например): 4

// Получаем несколько случайных элементов
$random_elements = array_rand($array, 3);
keks_log($random_elements); // Выведет (например): [0, 2, 5]
Нам нужно получить три случайных промо-товара. Для этого вызовем функцию array_rand с аргументами $promo_products и 3. Функция вернёт массив с тремя идентификаторами. Используем эти идентификаторы, чтобы вывести товары на страницу. Массив, который вернёт функция array_rand, простой, не ассоциативный. Чтобы перебрать его элементы, будет достаточно записи:

foreach($array as $item)
Проверим, что товары, которые в результате отобразятся на странице, действительно случайные.

Урок 16. 

Закрыть
Функция shuffle, перемешиваем массив
Мы вывели на страницу три случайных промо-товара. Но кажется, что товары не совсем случайны. Первым почти всегда оказывается дешёвый товар, а третьим — новый. Почему так?

Дело в том, что функция array_rand выбирает случайные элементы, но возвращает их в том порядке, в каком они идут в исходном массиве.

Представим, что у нас есть массив с числами и что мы хотим получить из него три случайных числа:

$array = [0, 1, 2, 3, 4, 5, 6];
$random_numbers = array_rand($array, 3);
В исходном массиве числа идут по возрастанию. Поэтому в $random_numbers может оказаться массив [0, 5, 6] или [1, 2, 4]. Но мы точно не получим массив [6, 0, 2] или [3, 2, 1], потому что в них числа выстроены не в том порядке.

Как сделать так, чтобы числа в $random_numbers не зависели от порядка в исходном массиве? Используем встроенную функцию shuffle. Она принимает массив и перемешивает его элементы. Будьте осторожны, функция shuffle изменяет переданный ей массив и не сохраняет ключи. С ассоциативными массивами её лучше не использовать.

shuffle($random_numbers);
Теперь числа в $random_numbers выстроятся в случайном порядке.

На главной странице интернет-магазина показываются случайные товары из массива $promo_products. В нём сначала идут дешёвые товары, а после — новые. Поэтому и на страницу чаще всего первым выводится дешёвый товар, а последним — новый.

Чтобы промо-товары на странице показывались в свободном порядке, их нужно перемешать. Но использовать функцию shuffle с ассоциативным массивом $promo_products нельзя, ведь тогда мы лишимся правильных идентификаторов товара. Вместо этого перемешаем массив $random_ids. У него нет ключей, только индексы, которые для этой задачи не важны. Перемешивать его безопасно.

Перемешаем массив $random_ids и убедимся, что теперь случайные товары выводятся в случайном порядке.


Курс 4. Знакомство с PHP. Часть 3: Массивы и функции в PHP


Урок 1. 
Закрыть
Выводим на страницу все товары из заказа
Вместе с командой Думпо мы продолжаем работу над интернет-магазином. Мы отлично потрудились в стартовом тренажёре и прошлых частях текущего тренажёра, но некоторые страницы ещё требуют доработки. Например, страница доставки.

В части про условия мы рассчитали и вывели на страницу итоговую цену и стоимость доставки одного товара. Но в заказе может быть несколько товаров. В этом случае нужно показать информацию о каждом из них.

В массиве $order записаны идентификаторы товаров, которые содержатся в заказе.

$order = [2, 7, 15, 16];
С помощью цикла foreach выведем на страницу доставки все товары из массива $order.

<?php foreach($order as $id): ?>
  ...
<?php endforeach; ?>
Мы уже работали с массивами и циклами в прошлой части.


Урок 2. 
Закрыть
Выводим на страницу все товары из заказа
Вместе с командой Думпо мы продолжаем работу над интернет-магазином. Мы отлично потрудились в стартовом тренажёре и прошлых частях текущего тренажёра, но некоторые страницы ещё требуют доработки. Например, страница доставки.

В части про условия мы рассчитали и вывели на страницу итоговую цену и стоимость доставки одного товара. Но в заказе может быть несколько товаров. В этом случае нужно показать информацию о каждом из них.

В массиве $order записаны идентификаторы товаров, которые содержатся в заказе.

$order = [2, 7, 15, 16];
С помощью цикла foreach выведем на страницу доставки все товары из массива $order.

<?php foreach($order as $id): ?>
  ...
<?php endforeach; ?>
Мы уже работали с массивами и циклами в прошлой части.


Урок 3.  

Аргументы функции
Мы объявили функцию и научились вызывать её. Но пока наша функция не очень полезна — она просто выводит в консоль одну и ту же фразу. Как сделать так, чтобы функция выводила итоговую цену товара, причём для каждого товара — свою?

Используем аргументы функции. Они позволяют передавать функции разные данные и влиять на результат её работы.

Аргументы указывают в круглых скобках при объявлении функции. Аргументов может быть сколько угодно. Если их несколько, они указываются через запятую.

Аргументы похожи на переменные. Они тоже хранят значения, и их имена должны начинаться со знака доллара. Аргументы можно использовать только в теле функции:

function my_func($number_1, $number_2) {
  keks_log($number_1 - $number_2);
}
Функция в примере принимает два аргумента, вычитает второй аргумент из первого и выводит результат в консоль. Но как она узнает, какие числа использовать? Для этого функции надо передать значения аргументов.

Значения аргументов указывают в круглых скобках при вызове функции. Их перечисляют через запятую в том же порядке, что и аргументы при объявлении функции.

my_func(3, 1); // Выведет: "2"
my_func(1, 3); // Выведет: "-2"
Подробнее о том, как устроены функции, вы можете почитать в учебнике по PHP.

Нам нужно посчитать итоговую цену товара. Чтобы её получить, надо из полной цены вычесть скидку. Укажем, что функция get_final_price принимает два аргумента: $price и $discount — и выводит в консоль их разницу. После этого вызовем функцию, передав ей разные значения.

https://htmlacademy.ru/tutorial/php/functions


Урок 4. 

Функция возвращает значение
Мы научились передавать функции аргументы, считать итоговую цену товара и выводить её в консоль. Но что будет, если вызвать функцию get_final_price в шаблоне?

<td><?= get_final_price(1000, 200) ?></td>
В консоли появятся новые сообщения, но в мини-браузере итоговая цена не отобразится, потому что команда keks_log выводит сообщение в консоль, но не на страницу. Чтобы итоговая цена появилась на странице, функция get_final_price должна её вернуть.

Функции могут не только принимать данные, но и возвращать их. Представьте, что мы задаём функции вопрос, а она на него отвечает. Чтобы указать, что именно функция должна ответить, или какое значение вернуть, используют ключевое слово return:

function my_func($number_1, $number_2) {
  return $number_1 - $number_2;
}
Когда функцию вызовут, на её место в коде подставится то значение, которое она вернёт:

<!-- Вызываем функцию в шаблоне -->
<p><?= my_func(3, 1) ?></p>

<!-- Результат  -->
<p>2</p>
Вернув значение, функция прекратит работу. Последующий код в теле функции PHP проигнорирует.

function my_func($number_1, $number_2) {
  return $number_1 - $number_2;

  // Код на следующей строке никогда не будет исполнен
  keks_log('Есть ли жизнь после return?');
}
Функция может ничего не возвращать или вернуть одно любое значение: число, строку, массив и так далее.

Итак, нам нужно вывести на страницу итоговую цену товара. Укажем, что функция get_final_price возвращает разницу между полной ценой и скидкой на товар. После этого вызовем функцию в шаблоне components/delivery_info.php. Используем для вставки PHP-кода краткую запись:

<?= my_func(3, 1) ?>


Урок 5. 

ередаём функции идентификатор товара
Мы создали функцию, которая возвращает итоговую цену, и вызвали её в шаблоне. В результате у всех товаров на странице снова отобразилась одна и та же цена. Мы зря создавали функцию? Ничего подобного. Чтобы показать правильную цену для каждого товара, осталось лишь передать функции правильные данные.

До этого мы вручную передавали функции полную цену и скидку на товар, но мы можем сказать функции самой получать их из базы данных. Используем специальные команды, чтобы узнать цену и скидку на конкретный товар:

get_product_price ($id) — цена;
get_product_discount ($id) — скидка.
Для обеих команд нужен идентификатор товара. Укажем, что функция get_final_price принимает его как аргумент. Другие аргументы больше не понадобятся:

function get_final_price($id) {
  ...
}
В теле функции узнаем цену и скидку на товар, чей идентификатор мы получили. Сохраним их в переменные:

$price = get_product_price($id);
$discount = get_product_discount($id);
Функция по-прежнему будет возвращать разницу между $price и $discount, но теперь их значения будут браться из базы данных, а не из аргументов.

Идентификаторы товаров хранятся в массиве $order. С помощью foreach в шаблоне мы получаем новый идентификатор на каждой итерации цикла.

<?php foreach($order as $id): ?>
Вызовем функцию get_final_price внутри цикла и передадим ей в качестве аргумента идентификатор товара. На каждой итерации цикла функция будет вызываться заново, с новым идентификатором. В результате для разных товаров выведется разная итоговая цена.

Вы заметили, что использование команд из базы данных очень похоже на вызовы функций? Это они и есть. Команды get_product_price и get_product_discount — самые обычные функции, просто написанные другими разработчиками.

Переменные, объявленные внутри функции, доступны только внутри этой функции. А внешние переменные, наоборот, внутри функции не видны. Это называется областью видимости. Вы можете узнать о ней больше в документации.

https://www.php.net/manual/ru/language.variables.scope.php




Урок 6. 

Вычисляем стоимость доставки
С помощью функции get_final_price мы посчитали итоговую стоимость для каждого товара в заказе. Теперь вычислим для каждого товара стоимость доставки.

Стоимость мы уже считали в одной из прошлых частей. Думпо скопировал наши старые вычисления и добавил их в сценарий.

// Получаем данные о товаре
$price = get_product_price($id);
$discount = get_product_discount($id);
$is_new = get_product_is_new($id);
$final_price = $price - $discount;

// Стоимость доставки зависит от итоговой цены и новизны товара
if ($is_new && $final_price < 2000) {
  $delivery_cost = $final_price;
} else {
  $delivery_cost = $final_price / 20;
}
Используем функцию, чтобы вывести на страницу стоимость доставки для каждого товара в заказе. Действовать будем по аналогии с итоговой ценой.

Создадим функцию get_delivery_cost, которая принимает идентификатор товара и возвращает стоимость его доставки. Переместим вычисления в тело функции, после чего вызовем её в шаблоне.

Урок 7.

Оптимизируем функцию
Мы создали функцию, которая считает стоимость доставки товара. Функция работает, но код получился избыточным и негибким. Посмотрим, почему так вышло.

Стоимость доставки зависит от итоговой цены. Чтобы получить её внутри функции get_delivery_cost, мы снова берём данные из базы и вычитаем скидку из полной цены товара. Но ведь для этого уже есть функция get_final_price! Лучше использовать её. В таком случае, если изменится формула, править вычисления придётся только в одном месте.

Сделаем наш код универсальным. Вызовем функцию get_final_price внутри функции get_delivery_cost, чтобы получить итоговую цену товара. После этого убедимся, что если изменить формулу итоговой цены, то стоимость доставки пересчитается автоматически.

Мы можем вызывать одну функцию внутри другой. Но что случится, если в теле одной функции объявить другую функцию? Это не будет ошибкой, но «внутреннюю» функцию можно будет вызвать только после того, как вызовут «внешнюю».

Урок 8. 
Урок 9. 
Урок 10. 
Урок 11. 
Урок 12. 
Урок 13. 
Урок 14. 
Урок 15. 
Урок 16. 

Курс 2. Знакомство с HTML и CSS. Часть 4: Основы CSS


Список CSS-правил мы называем «плоским», потому что в чистом CSS их нельзя вкладывать друг в друга. Возможно, в новых версиях языка эту возможность добавят.

Помимо CSS-правил (rule sets) в языке существуют так называемые «эт-правила» (at-rules), они начинаются с символа @, например, @font-face. «Эт-правила» ещё называют CSS-директивами.

Для решения наших текущих задач CSS-директивы не понадобятся, но мы обязательно познакомимся с ними позже.




Селектор находится в начале CSS-правила, до фигурных скобок, и определяет к каким HTML-элементам применятся свойства и значения из правила. Вспомните пример:

селектор {
  свойство: значение;
  свойство: значение;
}


.feature-kitten {
  padding-top: 60px;                        /* отступ сверху */
  background-image: url("img/bottle.svg");  /* фоновая картинка */
}






ростейшие (и самые популярные) селекторы — это селекторы по тегам и по классам. Селекторы по тегам содержат имя тега без символов < и > и применяются ко всем подходящим тегам. Селекторы по классам начинаются с точки, за которой идёт имя класса, и применяются ко всем тегам с подходящим атрибутом class. Например:

h1 { color: red; }      /* выберет все заголовки 1 уровня */
.info { color: blue; }  /* выберет только элементы с классом info */
Если у CSS-правил отличаются только селекторы, а свойства и значения одинаковые, то их можно сгруппировать через запятую. Например:

h1, .danger { color: red; }

/* То же самое, что и */

h1 { color: red; }
.danger { color: red; }









.feature-kitten {
  padding-top: 60px;                        /* отступ сверху */
  background-image: url("img/bottle.svg");  /* фоновая картинка */
}
В примере свойству padding-top задаётся значение 60px, а свойству background-image значение url("img/bottle.svg"). В итоге, это CSS-правило задаёт всем элементам с классом feature-kitten отступ сверху и фоновое изображение.

С помощью CSS можно задавать параметры отображения любого тега: ширину и высоту, отступы, цвет и размер шрифта, фон и так далее. Каждый раз, когда мы добавляем новое свойство или изменяем его значение, мы меняем что-то на странице. Давайте попробуем добавить несколько новых свойств и посмотрим, что изменится на странице блога.










На прошлом шаге мы задали белый цвет текста для nav, а он применился и для заголовка «Записи в блоге». Почему это произошло? Всё дело в наследовании.

Наследование в CSS — это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам.

Стили, присвоенные одному элементу, наследуются всеми потомками (вложенными элементами), но только в том случае, если они где-то явно не переопределены. Например, размер шрифта и его цвет достаточно применить к body, чтобы большинство элементов внутри имели те же свойства. Рассмотрим пример наследования:

body {
  font-size: 14px;
}

nav {
  font-size: 18px;
}



Размер шрифта у всего текста на странице, кроме текста внутри навигации, станет равен 14px. У nav есть своё объявленное значение размера шрифта (18px), и оно будет использоваться вместо наследуемого от body значения (14px). А ещё 18px станет новым наследуемым значением для потомков nav.


Если на странице из примера будут заголовки, то их размер тоже будет отличаться от 14px. Дело в том, что размер для заголовков тоже кое-где явно задан (и это кое-где мы обсудим в 11 задании). А значит у заголовков есть объявленное значение, которое будет использоваться вместо наследуемого значения.

Давайте убедимся, что наследование действительно работает. Смените название шрифта для всего body.







Наследуемые свойства
На самом деле не все свойства в CSS наследуются. К наследуемым относятся в основном свойства, определяющие параметры отображения текста:

font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и другие.
Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно реже.



Наследуемые свойства можно и нужно задавать через предков, следуя структуре документа.

Например, параметры текста зачастую не меняются в пределах крупных блоков страницы: меню, основного содержания, информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях этих крупных блоков.

Давайте проверим работу ещё пары наследуемых свойств, а заодно добавим больше «воздуха» в тексты блога и сделаем их более удобными для чтения.

Весь список наследуемых свойств вы можете найти в стандарте CSS.(https://www.w3.org/TR/CSS22/propidx.html) Если в колонке Inherited? напротив свойства стоит yes, то свойство наследуемое, иначе ненаследуемое.











Ненаследуемые свойства
В предыдущем задании мы перечислили основные наследуемые свойства. Но не все свойства наследуются. Основные ненаследуемые свойства — это параметры позиционирования, размеров, отступов, фона, рамок:

background, border, padding, margin, width, height, position и другие.

Не наследуются они из соображений здравого смысла. Например, если для какого-либо блока установлен внутренний отступ, автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.





Закрыть
Составные свойства
В CSS есть обычные свойства, управляющие одним параметром отображения, и есть составные свойства, управляющие одновременно несколькими параметрами.

Например, свойство font-size — обычное, оно управляет только размером шрифта. А свойство font — составное, оно задаёт сразу шесть параметров: размер и название шрифта, высоту строки и некоторые другие. Браузер всегда «расшифровывает» составные свойства в обычные. Например, такое составное свойство:


font: 16px/26px "Arial", sans-serif;


Браузер «расшифрует» в такой набор обычных свойств и их значений:

font-size: 16px;                  /* было задано в font */
line-height: 26px;                /* было задано в font */
font-family: "Arial", sans-serif; /* было задано в font */
font-weight: normal;              /* не было задано в font */
font-style: normal;               /* не было задано в font */
font-variant: normal;             /* не было задано в font */



Если значение обычного свойства не было задано в составном, то браузер при «расшифровке» использует исходное значение этого свойства. В примере значение 16px для font-size взято из font, а для font-weight использовано исходное значение — normal.

Составное свойство всегда задаёт значения всем своим компонентам. Для не заданных явно компонентов используются исходные значения. Поэтому составные свойства нужно использовать с осторожностью. Например, если забыть описать высоту строки:

font: 16px "Arial", sans-serif;
То для line-height браузер возьмёт исходное значение, и внешний вид текста может оказаться плохим.

Пора добавить странице блога красивый фон. Используем для этого составное свойство background.





Типы значений: абсолютные и относительные
Давайте сделаем аватарку модной, то есть круглой. Можно увеличить значение border-radius до половины размера аватарки, то есть до 40px, и получить круг. Но если потом появится новая аватарка с другими размерами, то снова придётся менять стили. Можно ли сразу сделать универсально? Да! С помощью процентов:

border-radius: 50%;
Если радиус скругления задать в процентах, то он будет рассчитываться относительно размеров элемента и будет изменяться вместе с этими размерами. Если этот радиус задать в пикселях, то он абсолютно всегда будет одинаковым. Вот и единицы измерения в CSS делятся на абсолютные и относительные.

Абсолютные единицы измерения привязаны к настоящим физическим размерам и связаны между собой жёсткими пропорциями. Примеры абсолютных единиц измерения:

font-size: 1cm;  /* 1 сантиметр  */
font-size: 10mm; /* В 1 сантиметре 10 миллиметров */
font-size: 38px; /* В 1 сантиметре 38 попугаев пикселей */
Пиксели, px, используют чаще всего, остальные абсолютные единицы почти не применяют.

Относительные единицы измерения описывают значения, которые зависят от других значений. Например, ширина элемента в процентах зависит от ширины родительского элемента, а ширина элемента в em зависит от размера шрифта самого элемента.

К относительным единицам относятся em, rem, vh, vw и некоторые другие, ну и, конечно же, проценты. Каждая из таких единиц решает свой круг задач. Например, проценты используют для «резиновой» вёрстки, а em применяют в вёрстке государственных сайтов с особыми дополнительными требованиями к масштабированию текста.

Перечень всех абсолютных единиц измерения и их соотношений есть в спецификации. Там же, в спецификации, есть перечень всех относительных единиц измерения и описание правил расчёта.



https://www.w3.org/TR/css3-values/#absolute-lengths - абсолютные значения
https://www.w3.org/TR/css3-values/#relative-lengths - относительные значения




Вложенные селекторы
Если селекторы по тегам нужно использовать пореже, а по классам почаще, то придётся каждому тегу в разметке добавлять класс? Нет, это ненужное усложнение кода.

Зачем мы использовали классы? Чтобы ограничить количество тегов, к которым применится CSS-правило: не ко всем тегам, а к тегам с нужным классом. Но ограничивать область применения стилей можно и по-другому. Вот список внутри навигации:

<nav class="blog-navigation">
  <ul>…</ul>
</nav>
Как применить стили только к этому списку? Первый способ: добавить ему класс и использовать селектор по этому классу. Второй способ: использовать специальный селектор, чтобы стили применялись к спискам внутри блока с классом blog-navigation.

Вы можете комбинировать любые типы селекторов через пробел. Такие селекторы называются вложенными или контекстными и читаются справа налево. Например:

nav a {…}        /* выберет теги a внутри тегов nav */
.menu ul {…}     /* теги ul внутри тегов с классом menu */
.post .title {…} /* теги с классом title внутри тегов с классом post */
Узнали селектор nav a из второго задания? Он помог сделать ссылки белыми только в навигации, в остальном тексте они остались синими.

Комбинировать можно любое количество селекторов, но лучше использовать двойную или максимум тройную вложенность. Вложенные селекторы спасают нас от необходимости придумывать имена классов и загромождать ими разметку.

Давайте изменим пару селекторов в стилях блога, а заодно улучшим оформление заголовков и элементов списка внутри навигации (уже используя правильные селекторы).






Стили по умолчанию
Некоторым элементам можно не задавать никаких стилей, но у них всё равно будет какое-то оформление. Например, списки «без стилей» выглядят так:

первый пункт списка,
второй пункт списка,
третий пункт списка.
У списка есть отступы и маркеры, но откуда они берутся? Потому что список такой «сам по себе»? Нет! Параметры оформления тегов описываются только в CSS, и наши списки — не исключение. Значит где-то есть стили, в которых спискам заданы отступы и маркеры? Да! И эти стили хранятся внутри браузера, это браузерные стили по умолчанию.

Помните, как в 4 задании мы говорили, что размер шрифта body не будет наследоваться заголовками? Это происходит из-за того, что размер шрифта заголовков явно задан внутри браузерных стилей по умолчанию (и наследуемое от body значение им не нужно).

Ваши навыки существенно подросли! Пора сделать раздел про них более подробным. Как всегда начнём с разметки. Для описания уровня навыков лучше всего подойдёт список определений. Заодно посмотрите, что у тегов dl/dt/dd тоже есть стили по умолчанию.






Закрыть
Каскадирование
Вот мы и подобрались к одному из самых важных механизмов CSS — каскадности. Именно он скрывается за первой С в аббревиатуре CSS (Cascading Style Sheets).

Когда браузер отрисовывает страницу, он должен определить итоговый вид каждого HTML-элемента. Для этого он собирает все CSS-правила, которые относятся к каждому элементу, ведь на элемент могут влиять сразу несколько CSS-правил. Например:

<p class="beloved-color">Зелёный - мой любимый цвет</p>
На этот элемент могут одновременно влиять CSS-правила по тегу p и по классу beloved-color из наших стилей, да ещё и CSS-правило по тегу p из браузерных стилей.

После того, как все правила для элемента собраны, браузер комбинирует все свойства из этих правил и применяет их к элементу. Если в наших стилях есть такой код:

p { font-size: 14px; }
.beloved-color { color: green; }
То у нашего абзаца про цвет будет такой итоговый набор свойств и значений:

font-size: 14px; /* из правила для p в наших стилях */
color: green;    /* из правила для .beloved-color в наших стилях */
margin: 1em 0;   /* из правила для p в браузерных стилях */
Этот механизм комбинирования стилей из разных источников в итоговый набор свойств и значений для каждого тега и называется каскадностью.

Давайте продолжим оформление списка навыков, а заодно применим каскад.








Конфликт свойств
На один элемент могут действовать несколько CSS-правил. Если в этих правилах есть одинаковые свойства с разными значениями, то возникает конфликт. Например:

ul { list-style: disc; }                   /* браузерные стили */
.blog-navigation ul { list-style: none; }  /* наши стили */
На один и тот же список в нашем блоге действуют стили с разными значениями свойства list-style. Это и есть конфликт, ведь у свойства может быть только одно значение.

Браузеру нужно как-то решать, какими будут итоговые значения конфликтующих свойств. Конфликт разрешается максимум за три шага. Если на текущем шаге определиться не удалось, то выполняется следующий шаг. Вот эти шаги:

Сравниваются приоритеты стилевых файлов, в которых находятся конфликтующие свойства. Например, авторские (то есть наши) стили приоритетнее браузерных.
Сравнивается специфичность селекторов у CSS-правил с конфликтующими свойствами. Например, селектор по классу более специфичен, чем селектор по тегу.
Побеждает то свойство, которое находится ниже в коде.
Мы подробно разберём приоритеты, специфичность селекторов и прочие тонкости наследования и каскадирования в соответствующей части. А пока вспомните margin: 0; для .skills dd на прошлом шаге. Свойство из наших стилей (более приоритетных) вступило в конфликт со свойством из браузерных стилей и победило, обнулив отступы.

Другой конфликт возник в правиле .skills dd при появлении там margin-bottom:

margin: 0;
margin-bottom: 10px;
Каскад работает и внутри CSS-правил, поэтому в конфликт вступили «обычный» margin-bottom и аналогичный компонент составного свойства. «Обычное» свойство победило, так как находится ниже в коде:

margin-left: 0;   /* из составного свойства */
margin-top: 0;    /* из составного свойства */
margin-right: 0;  /* из составного свойства */
margin-bottom: 0; /* из составного свойства */
margin-bottom: 10px;



Множественные классы

 Допустим, у вас на сайте есть разные типы уведомлений:

<div class="alert">Прост сообщение.</div>
<div class="alert alert-error">Оши-ы-ы-бка! Всё пропа-а-а-ло!</div>
У них все стили кроме фона одинаковые. Фон обычных сообщений серый, фон ошибок красный. Стили для этих уведомлений можно организовать так:

.alert {
  /* свойства для рамок, отступов и так далее */
  background-color: lightgrey;
}
.alert-error { background-color: red; }
Класс alert с общими стилями есть у всех сообщений. Класс alert-error с частными стилями есть только у ошибок. Помните: несколько классов в атрибуте class задаются через пробел.

Почему код лучше организовать именно так? Мы уже знаем, как работает каскад в CSS, поэтому ответить будет легко.

Использование нескольких классов в разметке помогает явно указать, какие стили будут смешиваться с помощью каскада. И, конечно, эти стили удобнее всего разместить в коде рядом друг с другом.

Использование однотипных селекторов (например, по классам) позволяет использовать самый простой механизм разрешения конфликтов — по порядку в коде. Размещаем частные CSS-правила после общего, и всё что нужно точно переопределится.


<div style="width: 50%;"></div>



Логотип в шапке сайта
В этой части Кексби-тренажёра мы начнём «оживлять» страницу! Вы будете добавлять в разметку ссылки и вставлять картинки.

Пришло время вставить на страницу логотип. Вот несколько важных замечаний про логотипы:

Логотипы вставляют с помощью тега img, так как логотип — это содержательное, а не декоративное изображение.
Есть ошибочный подход, когда логотип вставляют фоном, например, у тега h1. Фон предназначен для вставки декоративных изображений.
На всех страницах сайта, кроме главной, логотип оборачивают в ссылку, которая ведёт на главную. На главной странице ссылка на логотипе не нужна, так как ссылка не должна вести сама на себя.
Учитывая эти замечания, мы добавим див с классом header-logo, а внутри него вставим изображение. Обязательно зададим логотипу размеры и альтернативный текст.




Ссылки на источники в разделе «Немного теории»
В заголовках статей есть информация об источниках, которая содержит ссылки на другие сайты. Если ссылка ведёт на страницу своего сайта, то её называют внутренней, а если она ведёт на другой сайт, то внешней. Эти внешние ссылки мы сейчас и разметим.

Ссылки могут открываться в текущей или в новой вкладке браузера. За это поведение отвечает атрибут target тега a и его значения:

_self — ссылки открываются в той же вкладке, это значение по умолчанию.

_blank — ссылки открываются в новой вкладке (или в новом окне браузера, если он не поддерживает вкладки).

Это не все значения атрибута, ещё есть _parent и _top, которые ведут себя почти как _self и уже давно нигде не используются.

Есть много споров о том, как должны открываться ссылки: в новой вкладке или в текущей. Но мы не будем вдаваться в подробности, так как наш заказчик, Кекс, уже всё решил: «Если ссылка внешняя, то пусть открывается в новом окне, чтобы с моего сайта не уходили, мур-мяу и точка!»













Оставшиеся изображения товаров
В предыдущем задании вы добавили картинку для первого товара, а теперь добавьте по аналогии изображения остальных товаров.

В каждом задании мы просим вас указывать размеры изображений с помощью атрибутов width и height тега img. Но зачем это нужно, ведь размер картинок от этого не меняется?

Указывая размеры картинок в атрибутах (и не просто размеры, а настоящие размеры картинок) мы помогаем браузерам быстрее и эффективнее отрисовывать наши страницы. Если браузер знает размеры картинки из HTML-кода, то он может выделить место под неё на странице ещё до загрузки картинки. А когда такая картинка загрузится, браузеру не придётся заново перерисовывать всю страницу.

Так что старайтесь всегда указывать реальные размеры изображений, которые вы вставляете через тег img в соответствующих атрибутах этого тега.
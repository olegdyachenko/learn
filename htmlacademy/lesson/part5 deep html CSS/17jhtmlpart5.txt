Курс 5. Погружение в HTML и CSS. Часть 1: Сетки


Урок 1. 

Боксовая модель
В этом тренажёре мы разберём продвинутые техники создания сайтов. В частности, поговорим о том, как располагать элементы на странице, то есть о сетках.

В тренажёре «Знакомство с HTML и CSS» мы познакомились со многими тегами. Каждому из этих тегов на странице соответствует прямоугольная область, которая называется боксом (от английского box — «коробка»).

Бокс состоит из содержимого (content), внутренних отступов (padding), рамки (border) и внешних отступов (margin):

Схема бокса
То, как бокс выглядит на странице, во многом зависит от его типа (или от типа его родителя). С боксами двух типов — блочными и строчными — мы уже работали в тренажёре «Знакомство с HTML и CSS», хоть и не упоминали их типы.

Блочные боксы на странице начинаются с новой строки и растягиваются на всю ширину родительского элемента. Блочный тип по умолчанию имеют, например, теги <p>, <div> и <h1>.

Заголовок
Абзац

Строчные боксы располагаются друг за другом на одной строке, а их ширина зависит от их содержимого. По умолчанию строчными боксами являются, например, теги <a>, <span> и <b>.

Ссылка Произвольная строка текста Текст, выделенный полужирным
Хорошему верстальщику нужно уметь видеть боксы на странице. Потренируем этот навык. Подключим специальный стилевой файл для подсветки боксов, а после добавим на страницу новые боксы разных типов.


Урок 2. 

Закрыть
Поток
Мы посмотрели, как выглядят боксы. Теперь разберём, как ими управлять.

То, как боксы взаимодействуют друг с другом и в каком порядке располагаются на странице, называется потоком. Например, если в потоке находятся блочные боксы, то по умолчанию они выстраиваются сверху вниз и занимают всё доступное пространство по ширине. Такое поведение называют нормальным потоком.

Схема нормального потока
Потоком можно управлять. Например, если изменить с помощью CSS тип боксов и некоторые свойства по умолчанию, то можно заставить боксы выстроиться в несколько колонок или расположиться по центру страницы. Так что одна и та же разметка может выглядеть по-разному.

Схема сложной сетки
Посмотрим, как всего лишь изменяя классы у тега <main>, можно управлять потоком страницы.


Урок 3.  

Сетка и макет страницы
Мы познакомились с боксами и убедились, что потоком можно управлять. Научившись изменять поведение боксов в потоке, вы сможете строить сетки любой сложности.

Сеткой называют расположение крупных боксов на странице. К таким боксам обычно относят шапку, подвал сайта, основное (<main>) и дополнительное (<aside>) содержимое, различные секции и разделы. Как правило, количество сеточных элементов на странице не меняется, а их размеры задаются согласно макету.

Макет — это изображение веб-страницы. Его создаёт дизайнер, а веб-разработчик использует его как образец при вёрстке. Макеты можно создавать в графическом редакторе или в специальных программах.

Вот макет страницы, которую нам предстоит сверстать:

Макет страницы
Разметка страницы и декоративные стили уже готовы, осталось только правильно сверстать сетку. Декоративные стили (с большинством свойств оттуда вы познакомились в тренажёре «Знакомство с HTML и CSS») были вынесены в отдельный файл. В обычной жизни так не поступают, но так проще учиться работать с сеткой.

Начнём с того, что подключим на страницу три стилевых файла: с декоративными стилями, с подсветкой сеточных элементов и пустой, в котором будем писать сеточные стили.


Урок 4. 


Свойство display, тип бокса
Мы подключили на страницу декоративные стили и подсветили сеточные элементы. Теперь пойдём сверху вниз по макету и будем шаг за шагом выстраивать сетку страницы.

Первый сеточный элемент на странице — шапка. Она обозначается тегом <header>, который по умолчанию является блочным боксом. Внутри него находятся логотип (изображение, обёрнутое в ссылку) и заголовок.

<header class="page-header">
  <a class="logo">
    <img src="img/food_logo.svg" alt="Логотип">
  </a>
  <h1 class="header-title">Доставка правильного питания</h1>
</header>
Логотип занимает столько места, сколько нужно его содержимому. Заголовок же имеет блочный тип, поэтому он начинается с новой строки и тянется на всю ширину шапки. Из-за этого логотип и заголовок сейчас располагаются друг под другом. Но на макете они находятся рядом, как если бы были выстроены в две колонки:

Макет шапки
Расположить элементы в две колонки можно разными способами. Мы воспользуемся гридами (от английского grid — «сетка»). Это удобная и популярная технология. И у неё неплохая браузерная поддержка.

Чтобы с помощью гридов управлять расположением логотипа и заголовка, нужно изменить тип бокса у их родителя — тега <header>. За тип бокса в CSS отвечает свойство display. У этого свойства больше десятка возможных значений, все они перечислены в спецификации.

display: grid;
Бокс с типом grid называют грид-контейнером, а дочерние, то есть непосредственно вложенные в него теги — грид-элементами.

Хотя снаружи (для других элементов, например основного содержимого) грид-контейнер ничем не отличается от блочного бокса, грид-элементы внутри него ведут себя иначе. Например, даже строчные боксы начинают занимать всю доступную им область. Кроме того, в грид-контейнере по-другому ведут себя внешние отступы у элементов.

Шапка на нашей странице — это элемент с классом page-header, используем для стилизации соответствующий селектор. Превратим шапку в грид-контейнер и посмотрим, как поведут себя грид-элементы — логотип и заголовок. А в следующем задании займёмся колонками.

https://www.w3.org/TR/css-display-3/#the-display-properties


Урок 5. 

Свойство grid-template-columns, шаблон грид-контейнера
Нам нужно расположить логотип и заголовок в шапке в две колонки. Мы сделали шапку грид-контейнером, однако нескольких колонок не появилось. Всё потому, что по умолчанию грид-контейнер одноколоночный.

Чтобы это изменить, нужно описать шаблон грид-контейнера. Для этого используют свойство grid-template-columns:

.grid-container {
  display: grid;
  grid-template-columns: 100px 150px 80px;
}
Код в примере разобьёт содержимое грид-контейнера на три колонки шириной 100, 150 и 80 пикселей. Грид-элементы автоматически распределятся по колонками слева направо.

В шапке нам нужно получить две колонки шириной 210 и 200 пикселей:

Макет шапки
Потренируемся использовать свойство grid-template-columns, а после разделим содержимое шапки на колонки правильного размера.

Существуют и другие свойства для описания шаблона грид-контейнера. Например, grid-template-rows и grid-template-areas. О них подробно рассказано в этой части.


Урок 6. 

Закрыть
Свойство padding, внутренний отступ
Мы выстроили содержимое шапки в две колонки, как на макете. Но в шапке не хватает «воздуха». Чтобы элементы не прилипали к границам бокса, ему нужно добавить внутренние отступы.

Внутренним отступом называют расстояние между содержимым бокса и рамкой.

Схема внутреннего отступа
Внутренние отступы у элемента создают с помощью свойства padding. Если внутренние отступы одинаковы со всех сторон, то достаточно написать так:

.element {
  padding: 15px;
}
Код в примере задаст элементу внутренние отступы 15px со всех сторон. Такую запись называют краткой. Есть и другие виды краткой записи, о них мы поговорим чуть позже.

Если отступы с разных сторон различаются, то используют полную запись, указывая внутренний отступ отдельно для каждой стороны:

.element {
  padding-top: 5px;
  padding-right: 10px;
  padding-bottom: 15px;
  padding-left: 20px;
}
Свойство padding-top создаёт внутренний отступ сверху, padding-right — справа, padding-bottom — снизу, а padding-left — слева.

Необязательно задавать элементу внутренние отступы со всех сторон. Например, если внутренний отступ нужен только сверху, то достаточно использовать лишь padding-top.

Взглянем на макет шапки.

Макет шапки
С разных сторон в шапке разные отступы. Чтобы задать их, используем полную запись.

Если с трёх сторон отступы одинаковы, а с четвёртой отличаются, то иногда используют такой трюк:

.element {
  padding: 15px;
  padding-bottom: 30px;
}
Таким образом сначала элементу задают одинаковые отступы со всех сторон, а после переопределяют отличающуюся сторону.


Урок 7. 

Свойство margin, внешний отступ
Мы добавили шапке внутренние отступы. Но снаружи шапки на странице осталось свободное пространство. Откуда оно там взялось?

Дело в том, что многие современные браузеры добавляют тегу <body> внешние отступы 8px со всех сторон. Внешним отступом называют отступ от внешней границы элемента до границ родительского элемента или до соседних элементов.

Схема внешнего отступа
Чтобы управлять внешними отступами, используют свойство margin. У него, как и у padding, есть краткая и полная записи.

// Краткая запись
margin: 20px;

// Полная запись
margin-top: 0;
margin-right: 5px;
margin-bottom: 10px;
margin-left: 15px;
Свойство margin-top создаёт внешний отступ сверху, margin-right — справа, margin-bottom — снизу, а margin-left — слева.

Указывать все четыре свойства необязательно. Если требуется задать внешний отступ лишь с одной или нескольких сторон, то достаточно использовать только соответствующие свойства.

На макете у <body> внешних отступов нет, поэтому и со страницы их нужно убрать. Лишние отступы также есть и у следующего сеточного элемента на нашей странице — списка преимуществ. Он размечен с помощью тега <ul>. По умолчанию браузеры добавляют неупорядоченному списку внутренние и внешние отступы. Их придётся переопределить.

Итак, первым делом уберём внешние отступы у <body>, потом займёмся списком преимуществ. У списка есть класс features-list, используем его для стилизации. Сначала обнулим у списка внешние отступы сверху и снизу, а потом зададим внутренние отступы по 20px со всех сторон.

Макет списка преимуществ
Если какому-либо свойству задают нулевое значение, то единицы измерения обычно не указывают.


Урок 8. 

fr, доля доступного пространства
Мы переопределили браузерные стили для тега <body> и списка преимуществ, теперь займёмся потоком. Содержимое списка должно располагаться в две колонки:

Макет списка преимуществ
Чтобы сделать колонки, превратим список в грид-контейнер так же, как мы это сделали с шапкой в этом задании.

В списке преимуществ шесть элементов, а разбить их надо на две колонки. Если элементов в грид-контейнере больше, чем колонок, то следующие элементы автоматически переносятся на новую строку, или ряд, и так же разделяются на колонки. Например, в нашем случае получится три ряда.

По замыслу дизайнера, колонки в списке должны быть одинаковыми по размеру и занимать всё доступное пространство по ширине. Как это сделать, ведь мы не можем знать заранее, какого размера монитор у пользователя?

Используем для размера колонок особую единицу измерения — fr (сокращённое от fraction — «доля»). Она означает долю доступного пространства в грид-контейнере.

.grid-container {
  display: grid;
  grid-template-columns: 1fr 2fr;
}
Грид-контейнер в примере будет поделён на 3 равные части. Первая колонка получит одну часть ширины грид-контейнера, а вторая колонка — две части. Как бы ни изменялась ширина контейнера, пропорции колонок всегда будут одинаковыми.

fr можно использовать и вместе с пикселями. Например, вот так можно создать сетку, где правая колонка имеет фиксированную ширину 200px, а левая занимает всё оставшееся пространство:

.grid-container {
  display: grid;
  grid-template-columns: 1fr 200px;
}
Потренируемся задавать размеры в fr, чтобы лучше понять, как она работает. А после разделим содержимое списка преимуществ на две колонки одинаковой ширины.

Урок 9. 

Закрыть
Свойство gap, отступ между грид-элементами
Список преимуществ уже похож на себя из макета. Но не хватает отступов между элементами.

Макет списка преимуществ
Добавим эти отступы. Использовать в данном случае margin не очень удобно, ведь он также влияет на расстояние до границ родительского элемента. А ещё в грид-контейнере внешние отступы двух соседних элементов складываются и по горизонтали и по вертикали. Так что расстояние между элементами оказывается в два раза больше указанного.

Как быть? Используем свойство грид-контейнера gap. Оно задаёт расстояние между грид-элементами, но не влияет на расстояние между элементами и контейнером. Сравните:

Схема сравнения margin и gap
Обратите внимание, что gap добавляется грид-контейнеру, в то время как margin — элементам.

С помощью gap отступы можно указать отдельно по вертикали и по горизонтали: column-gap отвечает за расстояние между колонками, а row-gap — за расстояние между рядами.

.grid-container {
  column-gap: 15px;
  row-gap: 5px;
}
Если же отступы одинаковы, удобно использовать составное свойство gap:

.grid-container {
  gap: 20px;
}
Потренируемся указывать отступы между грид-элементами с помощью column-gap и row-gap. А после используем gap, чтобы задать элементам отступы как на макете.

Если указать для gap два значения, то первое задаст интервал между рядами, а второе — между колонками:

.grid-container {
  gap: 20px 50px;
}
Эта запись короче, но её труднее понять. Поэтому для разных отступов лучше использовать row-gap и column-gap.

Урок 10. 

Урок 11. КОНСПЕКТ ЧАСТЬ 1

Конспект «Сетки». Раздел 1
Бокс
Каждому тегу на странице соответствует прямоугольная область, которая называется боксом (от английского box — «коробка»).

Бокс состоит из содержимого (content), внутренних отступов (padding), рамки (border) и внешних отступов (margin):

Схема бокса
То, как бокс выглядит на странице, во многом зависит от его типа (или от типа его родителя).

Блочные боксы на странице начинаются с новой строки и растягиваются на всю ширину родительского элемента. Блочный тип по умолчанию имеют, например, теги <p>, <div> и <h1>.

Строчные боксы располагаются друг за другом на одной строке, а их ширина зависит от их содержимого. По умолчанию строчными боксами являются, например, теги <a>, <span> и <b>.

Поток, сетки и макет
То, как боксы взаимодействуют друг с другом и в каком порядке располагаются на странице, называется потоком. Потоком можно управлять, изменяя тип боксов и свойства по умолчанию.

Нормальный поток
Изменённый поток
Схема нормального потокаСхема сложной сетки
Сеткой называют расположение крупных боксов на странице. К таким боксам обычно относят шапку, подвал сайта, основное (<main>) и дополнительное (<aside>) содержимое, различные секции и разделы. Как правило, количество сеточных элементов на странице не меняется, а их размеры задаются согласно макету.

Макет — это изображение веб-страницы. Его создаёт дизайнер, а веб-разработчик использует его как образец при вёрстке.

Свойство padding
Внутренним отступом называют расстояние между содержимым бокса и рамкой.

Схема внутреннего отступа
Внутренние отступы у элемента создают с помощью свойства padding. Если внутренние отступы одинаковы со всех сторон, то достаточно написать так:

.element {
  padding: 15px;
}
Такую запись называют краткой.

Если отступы с разных сторон различаются, то используют полную запись, указывая внутренний отступ отдельно для каждой стороны:

.element {
  padding-top: 5px;
  padding-right: 10px;
  padding-bottom: 15px;
  padding-left: 20px;
}
Свойство padding-top создаёт внутренний отступ сверху, padding-right — справа, padding-bottom — снизу, а padding-left — слева.

Свойство margin
Внешним отступом называют отступ от внешней границы элемента до границ родительского элемента или до соседних элементов.

Схема внешнего отступа
Чтобы управлять внешними отступами, используют свойство margin. У него, как и у padding, есть краткая и полная записи.

// Краткая запись
margin: 20px;

// Полная запись
margin-top: 0;
margin-right: 5px;
margin-bottom: 10px;
margin-left: 15px;
Свойство margin-top создаёт внешний отступ сверху, margin-right — справа, margin-bottom — снизу, а margin-left — слева.

Свойство display
За тип бокса в CSS отвечает свойство display. У этого свойства больше десятка возможных значений, все они перечислены в спецификации.

display: grid;
Grid
Бокс с типом grid называют грид-контейнером, а дочерние, то есть непосредственно вложенные в него теги — грид-элементами.

Хотя снаружи (для других элементов, например основного содержимого) грид-контейнер ничем не отличается от блочного бокса, грид-элементы внутри него ведут себя иначе. Например, даже строчные боксы начинают занимать всю доступную им область. Кроме того, в грид-контейнере по-другому ведут себя внешние отступы у элементов.

По умолчанию грид-контейнер одноколоночный. Чтобы это изменить, нужно описать шаблон грид-контейнера. Для этого используют свойство grid-template-columns:

.grid-container {
  display: grid;
  grid-template-columns: 100px 150px 80px;
}
Существуют и другие свойства для описания шаблона грид-контейнера. Например, grid-template-rows и grid-template-areas.

Если элементов в грид-контейнере больше, чем колонок, то следующие элементы автоматически переносятся на новую строку, или ряд, и так же разделяются на колонки.

fr
fr (сокращённое от fraction — «доля») — особая единица измерения. Она означает долю доступного пространства в грид-контейнере.

.grid-container {
  display: grid;
  grid-template-columns: 1fr 2fr;
}
Грид-контейнер в примере будет поделён на 3 равные части. Первая колонка получит одну часть ширины грид-контейнера, а вторая колонка — две части. Как бы ни изменялась ширина контейнера, пропорции колонок всегда будут одинаковыми.

fr можно использовать и вместе с пикселями. Например, вот так можно создать сетку, где правая колонка имеет фиксированную ширину 200px, а левая занимает всё оставшееся пространство:

.grid-container {
  display: grid;
  grid-template-columns: 1fr 200px;
}
Свойство gap
Свойство gap задаёт расстояние между грид-элементами, но не влияет на расстояние между элементами и контейнером. Сравните:

Схема сравнения margin и gap
Свойство gap добавляется грид-контейнеру, в то время как margin — элементам.

С помощью gap отступы можно указать отдельно по вертикали и по горизонтали: column-gap отвечает за расстояние между колонками, а row-gap — за расстояние между рядами.

.grid-container {
  column-gap: 15px;
  row-gap: 5px;
}
Если же отступы одинаковы, удобно использовать составное свойство gap:

.grid-container {
  gap: 20px;
}


Урок 12. ЗАДАНИЕ МАКЕТ. было не сложной
Урок 13. 

Условия те же: разметка и декоративное оформление полностью готовы, от нас требуется только сверстать сетку. Для наглядности снова используем подсветку сеточных элементов.

Идти по макету опять будем сверху вниз. Внешние отступы у <body> уже убраны, а в шапке боксы располагаются один под другим — там поток изменять не надо. Поэтому переходим сразу к основному содержимому. Согласно макету, оно должно располагаться в две колонки:

Макет основного содержимого
Мы уже знаем, как сделать колонки с помощью гридов. Но есть и другой способ — флексбоксы (от английского flexible — «гибкий»). Это ещё одна очень популярная технология. Она появилась раньше гридов и поэтому чуть лучше поддерживается браузерами.

Чтобы использовать особые свойства флексбоксов, нужно с помощью display изменить тип элемента:

display: flex;
Бокс с типом flex называют флекс-контейнером, а его дочерние боксы — флекс-элементами.

Флекс-элементы автоматически выстраиваются вдоль главной оси. По умолчанию она направлена слева направо. Подробнее об осях рассказывается в части «Флексбокс. Знакомство».

Схема главной оси флекс-контейнера
Если мы сделаем <main> флекс-контейнером, его дочерние элементы выстроятся в ряд. Так как в основном содержимом два раздела, то мы получим две колонки. Если бы флекс-элементов было три, то и колонок вышло бы три и так далее.

Начнём верстать страницу. Сначала подключим стилевые файлы, а после превратим <main> из блочного бокса во флекс-контейнер и посмотрим, что из этого выйдет. Для стилизации основного содержимого используем класс page-main.


Урок 14. 


Свойство width, ширина элемента
Мы изменили тип у <main>, и его содержимое автоматически выстроилось в две колонки. Но сейчас они выглядят неаккуратно, а их размеры не соответствуют макету. Разберём, как это исправить.

По умолчанию флекс-элементы не переносятся на новую строку и ужимаются до содержимого. Поэтому раздел с фотографией сжался ровно до ширины картинки. Другой же раздел занял всё оставшееся пространство из-за текста. Текст, даже во флекс-элементе, старается занять столько места по ширине, сколько может.

Из-за этих особенностей сеточным флекс-элементам лучше всегда явно прописывать ширину. Для этого проще всего использовать свойство width:

width: 550px;
По умолчанию свойство width задаёт ширину содержимого бокса (content) и не учитывает внутренние отступы и ширину рамки.

Схема бокса
Рассмотрим пример:

.box {
  width: 100px;
  padding-left: 20px;
  padding-right: 30px;
  border: 5px solid black;
}
В этом случае полная ширина бокса окажется 160px, потому что ширина содержимого сложится с шириной отступов и рамок: 100px + 20px + 30px + 5px + 5px (рамка справа и слева).

Это поведение width можно изменить. О том, как это сделать, мы поговорим в одной из следующих частей.

Чтобы содержимое колонок не прилипало к краям боксов, следует добавить им внутренние отступы. Свойство padding работает для флекс-элементов так же, как для блочных боксов.

Макет основного содержимого
Зададим колонкам (разделу с классом bio и разделу с классом photo) фиксированную ширину и внутренние отступы.

Высоту бокса можно задать с помощью свойства height. Но обычно для сеточных элементов её не указывают.

Другой способ задать размеры флекс-элементу — использовать свойство flex-basis. О нём подробно рассказано в этом задании.


Урок 15. 

Свойство justify-content, выравнивание по главной оси
Мы задали ширину и внутренние отступы колонкам. Их суммарный размер оказался меньше ширины родительского контейнера, и справа осталось свободное место.

На макете колонки прижаты к противоположным краям, а свободное пространство сосредоточено между ними:

Макет основного содержимого
Чтобы прижать колонки к краям родительского контейнера, используем свойство justify-content. Это свойство флекс-контейнера, которое говорит, как расположить флекс-элементы на главной оси.

У него может быть несколько значений:

flex-start — флекс-элементы располагаются в начале главной оси (по умолчанию — слева);
flex-end — флекс-элементы располагаются в конце главной оси (по умолчанию — справа);
center — флекс-элементы располагаются в центре главной оси;
space-around — свободное пространство распределяется вокруг флекс-элементов;
space-between — свободное пространство распределяется между флекс-элементами, при этом первый и последний элемент прижимаются к краям флекс-контейнера.
Добавим <main> свойство justify-content и поэскпериментируем со значениями.


Урок 16. 

Автоматические внешние отступы
Мы закончили с колонками. Займёмся теперь самим <main>. Согласно макету, основное содержимое должно иметь фиксированную ширину и располагаться по центру страницы:

Макет основного содержимого
В вёрстке часто требуется расположить элемент по центру, или, как говорят разработчики, отцентровать элемент. Существует множество способов это сделать. Мы воспользуемся самым популярным. Для него требуется:

указать элементу ширину, которая меньше ширины родительского элемента;
задать элементу автоматические внешние отступы справа и слева.
Пойдём по порядку. Нам нужно, чтобы ширина центруемого элемента была меньше ширины родителя. Для тега <main> родительским элементом является <body>, который, будучи блочным боксом, растягивается на всю ширину окна браузера. Выходит, чтобы ширина <main> оказалась меньше ширины родительского элемента, достаточно, чтобы она была меньше ширины окна браузера.

Дальше для выравнивания элемента нужно задать ему отступы. Прежде для указания внешних отступов мы использовали значения в пикселях. Но у margin может быть и другое значение — auto. Например:

margin-left: auto;
Это значение говорит браузеру самому рассчитать размер внешнего отступа. Браузер не жадный, поэтому выделяет под отступ всё свободное пространство в родительском контейнере. Так что если указать автоматический внешний отступ слева, то элемент прижмётся к правой границе родительского элемента.

Если автоматические внешние отступы заданы и справа и слева, то свободное пространство поделится между ними поровну. В итоге элемент расположится прямо по центру.

Схема выравнивания по горизонтали
Итак, теперь мы знаем, как отцентровать основное содержимое. Укажем с помощью свойства width его ширину, а после зададим автоматические отступы справа и слева.

Это удобный трюк, но работает он с оговорками. Во-первых, таким образом не получится выровнять строчные боксы. Во-вторых, в блочном боксе (в отличие от флекс-контейнера) подобным образом можно выровнять элемент только по горизонтали.


Урок 17.

Добавляем обёртку
Мы сверстали основное содержимое страницы, теперь настала очередь подвала.

У подвала есть фон, который тянется на всю ширину страницы. Но содержимое при этом должно занимать лишь часть страницы и располагаться по центру.

Макет подвала
Чтобы отцентровать содержимое, но не затронуть фон подвала, придётся немного доработать разметку. Заключим всё содержимое подвала в дополнительный контейнер-обёртку, после чего выровняем его по центру.

Используем для обёртки тег <div>. Он не имеет семантического значения, поэтому идеально подходит для декоративных эффектов. Обычно для обёрток используют класс container или wrapper.

Чтобы отцентровать содержимое, зададим обёртке ширину и добавим автоматические внешние отступы справа и слева. Используем для отступов краткую запись:

margin: 0 auto;
Если указать для margin два значения, то первое применится к внешним отступам по вертикали, а второе — к внешним отступам по горизонтали. Вот так выглядит аналогичная полная запись:

margin-top: 0;
margin-right: auto;
margin-bottom: 0;
margin-left: auto;
Краткую запись с двумя значениями часто используют, когда требуется отцентровать элемент. Однако в других ситуациях лучше к ней не прибегать, так как это ухудшает читаемость кода.

Итак, добавим в разметку контейнер-обёртку, после чего зададим ему ширину и внешние отступы.

Почему мы используем margin: 0 auto, а не margin: auto? Если речь идёт об обычном блочном боксе, а не о флекс-элементе, то разницы между этими значениями нет. Но если в дело вступает флекс, то разница появляется: margin: 0 auto отцентрует элемент только по горизонтали, а margin: auto и по горизонтали и по вертикали.

Даже если сейчас вы работаете с блочным боксом, в будущем тип родительского бокса может измениться. Поэтому лучше всегда явно указывать оба значения margin

Урок 18.

Разбиваем подвал на колонки
Мы выровняли содержимое подвала с помощью контейнера-обёртки. Теперь нужно распределить его содержимое по трём колонкам. Для этого превратим обёртку во флекс-контейнер.

И не забудем добавить внутренние отступы, чтобы содержимое не прилипало к краям.

Урок 19.

Выстраиваем колонки в подвале
Мы разбили содержимое подвала на три колонки. Теперь следует указать их ширину и добавить отступы между колонками.

Макет подвала
С шириной всё просто, а вот пространство между колонками распределено неравномерно. Если нужны разные внешние отступы, то justify-content не подойдёт. Нужно использовать margin.

Добавим первой колонке автоматический отступ справа — это оттолкнёт две другие колонки к правому краю флекс-контейнера. А чтобы разделить вторую и третью колонки, используем фиксированный отступ в пикселях.


Урок 20.

Закрыть
Выравниваем элемент по вертикали
Мы добавили ширину и отступы колонкам в подвале. Осталось выровнять содержимое второй колонки по вертикали. Как видно из макета, оно должно быть прижато к самому низу страницы:

Макет подвала
По умолчанию все флекс-элементы имеют одинаковую высоту, подстраиваясь под самый высокий элемент в ряду. Благодаря подсветке боксов это особенно заметно:

unknown@raccoon.ru
+7 999 999-99-99

© Неопознанный Енот

Логотип енота
Самый простой способ выровнять отдельный элемент по нижней границе — добавить ему автоматический внешний отступ сверху. В этом случае флекс-элемент уменьшит свою высоту под содержимое и прижмётся к низу родительского контейнера.

Обратите внимание, в блочном боксе автоматические внешние отступы сверху и снизу работают так же, как если бы их сделали равными 0. Но во флекс-контейнере они позволяют сдвинуть флекс-элемент к верхней или нижней границе. Или даже отцентровать элемент по вертикали, если задать верхний и нижний отступ одновременно.

Схема выравнивания по вертикали
Нам нужно прижать содержимое второй колонки к нижнему краю, поэтому добавим ей автоматический внешний отступ сверху.

После этого уберём подсветку боксов, так как она больше не нужна.

Для выравнивания отдельного флекс-элемента поперёк главной оси можно также использовать свойство align-self.

Для создания колонок на этой странице мы использовали флексы. Но пока мы затронули лишь часть их возможностей. Подробнее о вёрстке с помощью флексов рассказано в частях «Флексбокс. Знакомство» и «Флексбокс. Погружение».

В этой части мы научились управлять крупными сеточными элементами. В следующий раз займёмся мелкими.

Урок 21 КОНСПЕКТ

Конспект «Сетки». Раздел 2
Flex
Чтобы использовать особые свойства флексов (от английского flexible — «гибкий»), нужно с помощью display изменить тип элемента:

display: flex;
Бокс с типом flex называют флекс-контейнером, а его дочерние боксы — флекс-элементами.

Флекс-элементы автоматически выстраиваются вдоль главной оси. По умолчанию она направлена слева направо.

Схема главной оси флекс-контейнера
По умолчанию флекс-элементы не переносятся на новую строку и ужимаются до содержимого. Из-за этих особенностей сеточным флекс-элементам лучше всегда явно прописывать ширину.

По умолчанию все флекс-элементы имеют одинаковую высоту, подстраиваясь под самый высокий элемент в ряду. Самый простой способ выровнять отдельный элемент по нижней границе — добавить ему автоматический внешний отступ сверху. В этом случае флекс-элемент уменьшит свою высоту под содержимое и прижмётся к низу родительского контейнера.

Свойство justify-content
justify-content — свойство флекс-контейнера, которое говорит, как расположить флекс-элементы на главной оси.

У него может быть несколько значений:

flex-start — флекс-элементы располагаются в начале главной оси (по умолчанию — слева);
flex-end — флекс-элементы располагаются в конце главной оси (по умолчанию — справа);
center — флекс-элементы располагаются в центре главной оси;
space-around — свободное пространство распределяется вокруг флекс-элементов;
space-between — свободное пространство распределяется между флекс-элементами, при этом первый и последний элемент прижимаются к краям флекс-контейнера.
Свойство width
Чтобы указать ширину элемента, используют свойство width:

width: 550px;
По умолчанию свойство width задаёт ширину содержимого бокса (content) и не учитывает внутренние отступы и ширину рамки.

Схема бокса
.box {
  width: 100px;
  padding-left: 20px;
  padding-right: 30px;
  border: 5px solid black;
}
В этом случае полная ширина бокса окажется 160px, потому что ширина содержимого сложится с шириной отступов и рамок: 100px + 20px + 30px + 5px + 5px (рамка справа и слева).

Выравнивание по центру
В вёрстке часто требуется расположить элемент по центру, или, как говорят разработчики, отцентровать элемент. Для этого требуется:

указать элементу ширину, которая меньше ширины родительского элемента;
задать элементу автоматические внешние отступы справа и слева.
.element {
  width: 550px;
  margin-right: auto;
  margin-left: auto;
}
Это удобный трюк, но работает он с оговорками. Во-первых, таким образом не получится выровнять строчные боксы. Во-вторых, в блочном боксе (в отличие от флекс-контейнера) подобным образом можно выровнять элемент только по горизонтали.

Автоматические внешние отступы
У margin может быть значение auto. Например:

margin-left: auto;
Это значение говорит браузеру самому рассчитать размер внешнего отступа. Браузер выделяет под отступ всё свободное пространство в родительском контейнере. Так что если указать автоматический внешний отступ слева, то элемент прижмётся к правой границе родительского элемента.

Если автоматические внешние отступы заданы и справа и слева, то свободное пространство поделится между ними поровну. В итоге элемент расположится прямо по центру.

Схема выравнивания по горизонтали
В блочном боксе автоматические внешние отступы сверху и снизу работают так же, как если бы их сделали равными 0. Но во флекс-контейнере они позволяют сдвинуть флекс-элемент к верхней или нижней границе. Или даже отцентровать элемент по вертикали, если задать верхний и нижний отступ одновременно.

Схема выравнивания по вертикали
Если указать для margin два значения, то первое применится к внешним отступам по вертикали, а второе — к внешним отступам по горизонтали.

margin: 0 auto;
Краткую запись с двумя значениями часто используют, когда требуется отцентровать элемент. Однако в других ситуациях лучше к ней не прибегать, так как это ухудшает читаемость кода.




ПОСЛЕДНЕЕ ИСПЫТАНИЕ СДЕЛАЛ НА 93 процента. Что-то толи не понял. Толи не учел. Потом нужно будет еще раз пройтись. 
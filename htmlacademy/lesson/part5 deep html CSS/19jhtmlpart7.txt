Курс 5. Погружение в HTML и CSS. Часть 3: Микросетки. Продолжение


Урок 1. 

Закрыть
Начинаем верстать карусель
В прошлой части мы познакомились с микросетками. В этой части мы продолжим с ними работать и для начала сверстаем компонент карусель.

Макет карусели
Карусель состоит из заголовка, списка карточек и кнопок для пролистывания этих карточек. Заголовок и кнопки уже полностью свёрстаны. Декоративные стили для списка карточек и самих карточек также готовы. Осталось написать для них сеточные стили.

Сначала займёмся списком. Всего карточек в нём может быть сколько угодно, но одновременно будут видны только три. Остальные карточки пользователь сможет увидеть, пролистав карусель. За это в готовой карусели будет отвечать скрипт, но пока его нет, в разметке оставлены только три «видимые» карточки.

Центральная карточка считается текущей и крупнее двух других.

<ul class="cards-list">
  <li class="card">
    <!-- Содержимое карточки -->
    </li>
  <li class="card current">
    <!-- Содержимое центральной карточки -->
  </li>
  <li class="card">
    <!-- Содержимое карточки -->
  </li>
</ul>
Начнём верстать. Первым делом обнулим отступы по умолчанию у самого списка, а после зададим ширину и внутренние отступы карточкам.

Макет карусели
О том, как сверстать кнопки в виде стрелок, мы поговорим в одной из следующих частей тренажёра.


Урок 2. 

Закрыть
Добавляем отступы между карточками
Мы обнулили отступы у списка и задали ширину и внутренние отступы карточкам. Теперь нужно расположить карточки в ряд и добавить отступы между ними. Расположить карточки в ряд проще всего с помощью флексбокса, потому что флекс-элементы по умолчанию выстраиваются именно так.

Макет карусели
Обратите внимание, в карусели должен быть только один ряд карточек, поэтому нет необходимости разрешать перенос на новую строку.

Так как отступы между карточками должны быть фиксированными, используем для них свойство margin. Поступим так же, как в прошлой части: сперва добавим внешний отступ справа всем карточкам, а потом уберём его у последней карточки с помощью псевдокласса. Так как в карусели одновременно будут показываться только три карточки, то последней всегда будет третья карточка.

В прошлой части мы использовали псевдокласс :nth-child, чтобы выбрать каждый третий элемент. Сейчас нам нужно убрать отступ только у одной карточки, у третьей, поэтому селектор будет выглядеть немного иначе:

// Выберет третий элемент с классом item
.item:nth-child(3) { ... }
Сделаем список cards-list флекс-контейнером и добавим элементам с классом card внешний отступ справа. Потом с помощью псевдокласса :nth-child уберём лишний отступ у третьей карточки.

Выбрать последний элемент также можно с помощью псевдокласса :last-child.

Урок 3.  

Поперечная ось и свойство align-items
Мы выстроили карточки в ряд и добавили отступы между ними. Теперь нужно отцентровать карточки по вертикали.

Макет карусели
По умолчанию флекс-элементы растягиваются, подстраиваясь под самый высокий элемент в строке. В нашем случае это вторая карточка.

Чтобы первая и третья карточки перестали тянуться и расположились по центру, используем свойство align-items. Мы уже встречали его, когда работали с гридами. Во флексах это свойство управляет расположением элементов на поперечной оси.

Поперечная ось идёт перпендикулярно главной оси и по умолчанию направлена сверху вниз:

Схема осей флекса
Во флекс-контейнере свойство align-items может иметь следующие значения:

stretch — значение по умолчанию; элементы растягиваются на всю высоту поперечной оси.
flex-start — элементы сжимаются до содержимого и располагаются в начале поперечной оси (по умолчанию сверху);
flex-end — элементы сжимаются до содержимого и располагаются в конце поперечной оси (по умолчанию снизу);
center — элементы сжимаются до содержимого и располагаются по центру поперечной оси;
.flex-container {
  display: flex;
  align-items: flex-start;
}
Потренируемся использовать свойство align-items, а затем отцентруем карточки по вертикали.

Обратите внимание, свойство align-items действует на все элементы во флекс-контейнере, но так как высота средней карточки равна высоте всего контейнера, то, какое бы выравнивание мы этой карточке ни задали, это не будет заметно.


Урок 4. 

Свойство flex-direction, направление главной оси
Список готов. Перейдём к сеточным стилям самих карточек.

Макет карточек
Обратите внимание на порядок элементов внутри карточек. На макете первым идёт изображение, а следом за ним заголовок. В разметке же наоборот:

<li class="card current">
  <h3 class="title">Лайм</h3>
  <img class="image" src="img/lime.jpg" alt="Лайм">
  <p class="description">Добавит кислинку и уникальный аромат.</p>
  <a class="add-link" href="#">+ Добавить</a>
</li>
Изменять порядок элементов в разметке нежелательно — с точки зрения семантики, первым должен идти заголовок раздела, а уже потом все относящиеся к нему элементы. Как быть? Изменим визуальный порядок элементов!

Управлять визуальным порядком элементов удобно с помощью свойства order. Но это свойство работает только в грид- и флекс-контейнерах, а наши карточки — это элементы <li>, у которых блочный тип. Чтобы свойство order заработало, тип бокса у карточек придётся изменить. Что выбрать: грид или флекс? Подойдут оба, но у флексбокса лучше браузерная поддержка, поэтому используем его.

Однако если мы просто сделаем карточки флекс-контейнерами, элементы внутри выстроятся в ряд, и вёрстка сломается. Чтобы сохранить направление потока сверху вниз, придётся повернуть главную ось флекс-контейнера.

Схема осей флекса
За направление главной оси отвечает свойство flex-direction. По умолчанию у него значение row (ряд), но его можно изменить на column (колонка):

.card {
  display: flex;
  flex-direction: column;
}
В этом случае главная ось будет направлена сверху вниз, а поперечная — слева направо. В результате флекс-элементы внутри карточек выстроятся сверху вниз.

Схема повёрнутых осей флекса
Нам нужно, не меняя разметку, поменять местами картинку и заголовок в каждой карточке. Для этого сначала сделаем карточки флекс-контейнерами и повернём главную ось, а в следующем задании займёмся визуальным порядком элементов.


Урок 5. 

Свойство order, порядок элементов
Мы превратили карточки во флекс-контейнеры и сделали так, чтобы элементы выстроились сверху вниз. Теперь мы можем поменять местами заголовок и картинку, как того требует макет.

Макет карточек
Чтобы изменить визуальный порядок элементов, удобно использовать свойство order. В качестве значения свойство принимает число, причём оно может быть как положительным, так и отрицательным. По умолчанию у всех элементов свойство order равно нулю.

.element {
  order: 5;
}
Элементы выстраиваются от меньшего значения order к большему. Если у нескольких элементов одинаковое значение, используется их порядок в разметке.

Рассмотрим пример. Есть четыре разноцветных блока:

1. green
2. orange
3. blue
4. pink
Используем order, чтобы изменить их порядок:

.green {
  order: 1;
}

.orange {
  order: 0;
}

.blue {
  order: -1;
}

.pink {
  order: 0;
}
В результате блоки выстроятся в таком порядке:

1. green
2. orange
3. blue
4. pink
Первым оказался синий блок, потому что у него самое маленькое значение order. Следующее по возрастанию значение у оранжевого и розового блоков, но в разметке оранжевый идёт раньше. Самое большое значение order у зелёного блока, поэтому он отобразился последним.

Нам нужно сделать картинку первым элементом в карточке. По умолчанию у всех элементов значение order равно нулю. Поэтому самый простой способ сделать картинку первым элементом — задать ей значение order меньше нуля. Это может быть любое отрицательное число, но для простоты используем -1.

Потренируемся задавать разные значения order, чтобы понять, как работает это свойство. А затем поменяем местами заголовок и картинку.

Свойство order меняет порядок только внутри родительского контейнера. То есть переместить элемент из шапки в подвал с его помощью не получится.


Урок 6. 

Закрыть
Свойство align-self во флексе
Мы поменяли местами картинку и заголовок, но на этом работа с карточками не окончена. Обратите внимание на заголовок. Зелёная линия под ним — это нижняя граница элемента. Она тянется на всю ширину карточки, потому что сам заголовок тянется на всю ширину. На макете же он отцентрован и занимает столько места, сколько нужно его содержимому:

Лайм
Лайм
Добавит кислинку и уникальный аромат.

+ Добавить
Макет карточек
Обычно флекс-элементы сжимаются по ширине до содержимого, однако в карточке этого не произошло. Всё дело в направлении осей. По умолчанию флекс-элементы сжимаются по главной оси и растягиваются по поперечной. Таким образом, если главная ось направлена слева направо, то элементы сжимаются по горизонтали и растягиваются по вертикали.

Схема осей флекса
Если же главная ось направлена сверху вниз, то сжатие происходит по вертикали, а растяжение — по горизонтали.

Схема повёрнутых осей флекса
В карточках главная ось направлена сверху вниз. Поэтому, чтобы заголовок сжался по ширине до содержимого и расположился по центру, нужно задать ему выравнивание по поперечной оси. Мы уже знакомы со свойством align-items, которое управляет выравниванием всех флекс-элементов, но сейчас нам нужно отцентровать только заголовок.

Используем для этого свойство align-self. Оно задаётся флекс-элементу и говорит, как ему расположиться на поперечной оси. Значения у этого свойства такие же, как у align-items: stretch (значение по умолчанию), flex-start, flex-end и center.

.element {
  align-self: flex-end;
}
Потренируемся использовать свойство align-self, а после отцентруем заголовок.

Если главная ось направлена сверху вниз, то для выравнивания всех элементов по вертикали используют justify-content.


Урок 7. 

Отступы флекс-элементов
Мы отцентровали заголовок, и теперь для соответствия макету осталось только поработать с отступами.

Заголовок карточки размечен тегом <h3>, а описание — тегом <p>. Каждому из них браузер добавляет внешние отступы по вертикали, которые не совпадают с теми, что нарисовал дизайнер. Эти отступы придётся переопределить.

Лайм
Лайм
Добавит кислинку и уникальный аромат.

+ Добавить
Лайм
Лайм
Добавит кислинку и уникальный аромат.

+ Добавить
Задавая внешние отступы, следует помнить, что у соседних флекс-элементов они складываются.

Внешние отступы соседних элементов
Чтобы не запутаться и получить именно те размеры, которые указаны в макете, верстальщики добавляют элементам внешние отступы только с одной стороны. Часто внешние отступы задают в направлении потока. Если элементы выстроены горизонтально, то отступ задают справа, а у последнего элемента обнуляют:

Внешние отступы, горизонтальный поток
Если элементы выстроены вертикально, то отступ добавляют снизу. Исключение — самый последний элемент (например, подвал страницы), ему при необходимости задают отступ сверху:

Внешние отступы, вертикальный поток
В этом случае, даже если изменить порядок секций, они не слипнутся, и между ними не появятся лишние отступы.

Элементы в карточках выстроены сверху вниз. Поэтому мы добавим отступы снизу всем элементам, кроме ссылки, и обнулим верхние отступы по умолчанию у заголовка и абзаца. Ссылка — последний элемент, поэтому ей зададим внешний отступ сверху.

Макет карточки
Также ссылке нужно добавить внутренние отступы со всех сторон. Обратите внимание, что в нашем случае ссылка — не строчный бокс, а флекс-элемент. Поэтому отступы по вертикали у неё будут работать так же, как по горизонтали.

Отступы в карточках можно сверстать иначе. Например, можно задать абзацу с описанием отступ снизу 15px и не добавлять ссылке внешний отступ сверху.

Но в этом случае, если описание в карточке растянется на несколько абзацев, отступ между ними получится 15px. Это слишком много, такой отступ должен быть только после последнего абзаца. Поэтому внешние отступы у абзаца и ссылки лучше разделить.


Урок 8.
херня а не урок
Урок 9. 

Закрыть
Чиним вёрстку, свойства max-width и height
Мы увеличили картинку в одной из карточек, и вёрстка сломалась.

Так произошло потому, что карточкам задана фиксированная ширина. Если использовать картинку большего размера, она выпадет из контейнера. Чтобы не допускать подобного, верстальщики добавляют картинкам такие стили:

img {
  max-width: 100%;
  height: auto;
}
Свойство max-width задаёт максимальную ширину, а значение 100% говорит, что элемент не должен становиться больше ширины родителя.

Свойство height задаёт высоту элемента. Значение auto используют, чтобы изображение не деформировалось и сохраняло свои пропорции. Если его не указать, то будет использовано значение атрибута height из разметки, и изображение, скорее всего, исказится.

Этот способ работает, потому что у CSS-свойств max-width и height приоритет выше, чем у атрибутов width и height в разметке.

Добавим картинкам максимальную ширину 100% и автоматическую высоту. После этого увеличим картинки в оставшихся карточках и убедимся, что они не выпадают и не деформируются.

В браузере Safari картинки могут слегка деформироваться даже после добавления им максимальной ширины и автоматической высоты. Проблему можно решить, обернув картинку в любой подходящий тег, например <figure> или <div>.

Мы уже много раз тестировали вёрстку, изменяя содержимое компонентов. В настоящей работе вёрстку также необходимо тестировать в разных браузерах.
Урок 10. КОНСПЕКТ

Конспект «Микросетки. Продолжение». Раздел 1
Поперечная ось и свойство align-items (флекс)
Во флексах свойство align-items управляет расположением элементов на поперечной оси.

Поперечная ось идёт перпендикулярно главной оси и по умолчанию направлена сверху вниз:

Схема осей флекса
Во флекс-контейнере свойство align-items может иметь следующие значения:

stretch — значение по умолчанию; элементы растягиваются на всю высоту поперечной оси.
flex-start — элементы сжимаются до содержимого и располагаются в начале поперечной оси (по умолчанию сверху);
flex-end — элементы сжимаются до содержимого и располагаются в конце поперечной оси (по умолчанию снизу);
center — элементы сжимаются до содержимого и располагаются по центру поперечной оси;
Поворот главной оси, свойство flex-direction
Главную ось поворачивают, чтобы сохранить внутри флекс-контейнера направление потока сверху вниз. За направление главной оси отвечает свойство flex-direction. По умолчанию у него значение row (ряд), но его можно изменить на column (колонка):

flex-container {
  display: flex;
  flex-direction: column;
}
В этом случае главная ось будет направлена сверху вниз, а поперечная — слева направо. В результате флекс-элементы выстроятся сверху вниз.

По умолчанию флекс-элементы сжимаются по главной оси и растягиваются по поперечной. Таким образом, если главная ось направлена слева направо, то элементы сжимаются по горизонтали и растягиваются по вертикали.

Схема осей флекса
Если же главная ось направлена сверху вниз, то сжатие происходит по вертикали, а растяжение — по горизонтали.

Схема повёрнутых осей флекса
Получается, чтобы при повёрнутых осях выровнять элемент по горизонтали, нужно задать ему выравнивание по поперечной оси.

Свойство align-self (флекс)
Свойство align-self задаётся флекс-элементу и говорит, как ему расположиться на поперечной оси. Значения у этого свойства такие же, как у align-items: stretch (значение по умолчанию), flex-start, flex-end и center.

.element {
  align-self: flex-end;
}
Свойство order
Чтобы изменить визуальный порядок элементов, удобно использовать свойство order. В качестве значения свойство принимает число, причём оно может быть как положительным, так и отрицательным. По умолчанию у всех элементов свойство order равно нулю.

.element {
  order: 5;
}
Элементы выстраиваются от меньшего значения order к большему. Если у нескольких элементов одинаковое значение, используется их порядок в разметке.

Свойство order работает только в грид- и флекс-контейнерах.

Отступы у флекс-элементов
Внешние отступы у соседних флекс-элементов складываются.

Внешние отступы соседних элементов
Чтобы не запутаться и получить именно те размеры, которые указаны в макете, верстальщики добавляют элементам внешние отступы только с одной стороны. Часто внешние отступы задают в направлении потока. Если элементы выстроены горизонтально, то отступ задают справа, а у последнего элемента обнуляют:

Внешние отступы, горизонтальный поток
Если элементы выстроены вертикально, то отступ добавляют снизу. Исключение — самый последний элемент (например, подвал страницы), ему при необходимости задают отступ сверху:

Внешние отступы, вертикальный поток
В этом случае, даже если изменить порядок секций, они не слипнутся, а между ними не появятся лишние отступы.

Уменьшение изображений с сохранением пропорций
Если использовать картинку большего размера, чем родительский элемент, она выпадет из контейнера. Чтобы не допускать подобного, верстальщики добавляют картинкам такие стили:

img {
  max-width: 100%;
  height: auto;
}
Свойство max-width задаёт максимальную ширину, а значение 100% говорит, что элемент не должен становиться больше ширины родителя.

Свойство height задаёт высоту элемента. Значение auto используют, чтобы изображение не деформировалось и сохраняло свои пропорции. Если его не указать, то будет использовано значение атрибута height из разметки, и картинка, скорее всего, исказится.

Этот способ работает, потому что у CSS-свойств max-width и height приоритет выше, чем у атрибутов width и height в разметке.


Урок 11. ИСПЫТАНИЕ 75 процентов. не могу понять, что не так сделал. 

Урок 12. 

Верстаем асимметричную карточку
Сверстаем ещё одну карточку:

Макет карточки
Расположение элементов внутри карточки выглядит знакомо: содержимое разбито на две колонки, между рядами и колонками имеются отступы. Для такой сетки удобнее всего использовать гриды.

Однако карточка немного асимметрична: заголовок шире, чем список опций и первая колонка.

Макет карточки
Попробуем сверстать карточку, используя уже знакомые приёмы. Сперва разделим содержимое карточки на две колонки и добавим отступы.

.grid-container {
  display: grid;
  grid-template-columns: 100px 200px;
  gap: 10px;
}
Потом c помощью свойства width зададим заголовку ширину больше, чем ширина колонки.


Урок 13. 

Добавляем третью колонку
Мы задали заголовку ширину больше ширины колонки. В результате заголовок выпал из контейнера и наложился на описание.

Чтобы поправить карточку, разделим её не на две колонки, а на три. При этом заголовок, описание и дисклеймер растянем на две колонки, а список опций — на два ряда.

Макет карточки
Придумать подходящую структуру грид-контейнера бывает непросто. Если элементы расположены асимметрично, часто требуется больше колонок, чем кажется на первый взгляд.

Итак, разделим содержимое карточки на три колонки и растянем заголовок на две колонки с помощью свойства grid-column и ключевого слова span.

.element {
  grid-column: span 2;
}
При этом больше не нужно будет использовать свойство width для заголовка, так как его ширина будет ограничиваться шириной первых двух колонок.

Чтобы было удобнее верстать, в мини-браузере подсвечивается сетка грид-контейнера.


Урок 14. 

Закрыть
Используем грид-области
Мы разделили карточку на три колонки и растянули заголовок. Вышло неплохо, но элементы всё равно выстроились не так, как на макете: описание тарифа попало в третью, самую узкую, колонку и выпало из контейнера.

Тариф «Бесконечный разговор» с дополнительным пакетом СМС
Тариф для тех, кто действительно любит общение.

Безлимитные звонки.
Безлимитные соцсети.
Безлимитные мессенджеры.
600 СМС в день.
999₽
Не является публичной офертой.
Чтобы поправить карточку, нужно изменить визуальный порядок элементов. Мы уже знакомы со свойством order, но в данном случае удобнее будет не переставлять отдельные элементы, а описать шаблон карточки целиком, используя грид-области.

Грид-областью называют часть сетки грид-контейнера, у которой может быть имя. Имя области придумывает сам разработчик. Оно должно начинаться с буквы и может включать цифры, дефис и знак подчёркивания. Например: header, section-2, user_avatar. Следует выбирать такие имена, которые описывают содержимое области.

Используем грид-области, чтобы разместить элементы как на макете. Пойдём по порядку и сначала создадим грид-области для заголовка и блока с ценой. Им подойдут имена title и price.

Макет карточки
Чтобы описать структуру грида с помощью областей, используют свойство grid-template-areas. В нём указывают имена грид-областей. При этом каждый ряд оборачивают в кавычки, а колонки разделяют пробелом. Если требуется растянуть область на несколько колонок, её имя повторяют нужное число раз.

Нам нужно растянуть заголовок на две колонки и переместить блок с ценой в первый ряд:

.card {
  display: grid;
  grid-template-columns: 260px 165px 75px;
  grid-template-areas: "title title price";
}
Однако просто описать шаблон недостаточно, ведь браузер не знает, какие элементы мы имеем в виду. Чтобы связать имя области с соответствующим грид-элементом, используют свойство grid-area. Обратите внимание, в grid-area кавычки не нужны!

.title {
  grid-area: title;
}

.price {
  grid-area: price;
}
Этот код свяжет заголовок с областью title, а блок с ценой — с областью price. В результате оба элемента расположатся так, как описано в grid-template-areas, невзирая на их порядок в разметке.

Итак, опишем первый ряд карточки с помощью grid-template-areas, а после назначим подходящие имена заголовку и блоку с ценой. Заодно убедимся, что растягивать заголовок с помощью grid-column больше не нужно.

Имя области не обязано совпадать с селектором, но должно описывать содержимое элемента:

h1 {
  grid-area: title;
}
Элементы, которым не задано имя области, выстраиваются по сетке, как обычно.


Урок 15. 

Описываем несколько рядов
Мы познакомились с грид-областями, растянули заголовок на две колонки и переместили блок с ценой в первый ряд. Теперь нужно позаботиться об остальных элементах. Сначала придумаем подходящие имена областей:

Макет карточки
Потом опишем шаблон. Дисклеймер и описание тарифа нужно растянуть на две колонки. Мы уже знаем, как это сделать. Но обратите внимание на список опций — его нужно переместить в первую колонку и растянуть на два ряда.

В grid-template-areas можно указать сколько угодно рядов. При этом в кавычки оборачивают каждый ряд, но точка с запятой ставится только после последнего ряда! Для большей наглядности ряды записывают друг под другом:

grid-template-areas: "title title price"
                     "options description description";
Чтобы растянуть область на несколько рядов, достаточно повторить её имя в разных рядах. Нам нужно растянуть список опций на два ряда:

grid-template-areas: "title title price"
                     "options description description"
                     "options disclaimer disclaimer";
Дополним шаблон карточки в grid-template-areas, описав все необходимые грид-области. После этого назначим списку опций соответствующее имя области и убедимся, что он переместился в первую колонку и растянулся на два ряда.

Работу с описанием тарифа и дисклеймером закончим в следующем задании.


Урок 16. 

Завершаем шаблон карточки
Мы описали шаблон грид-контейнера и расположили список опций как на макете. Осталось поработать с описанием и дисклеймером. Мы уже указали их в шаблоне, теперь нужно назначить имена областей самим элементам.

Макет карточки
С помощью грид-областей можно очень быстро и наглядно описать сложную сетку и даже изменить визуальный порядок элементов. Однако у этого способа есть ограничения. Во-первых, грид-области должны быть прямоугольными и непрерывными.

// Такой код не сработает
grid-template-areas: "logo main"
                     "main main";

// Такой – тоже
grid-template-areas: "nav logo nav";
Во-вторых, при описании шаблона количество колонок в каждом ряду должно быть одинаковым:

// Такой код не сработает
grid-template-areas: "logo nav"
                     "aside main banner"
                     "footer";
Если задать неправильное значение grid-template-areas, браузер его проигнорирует, и вёрстка может сломаться.

Наконец, имена областей в одном контейнере должны быть уникальными. Если задать одинаковое имя нескольким элементам, они наложатся друг на друга. По этой причине грид-области не подойдут, например, для списка карточек, особенно если количество этих карточек неизвестно заранее.

Зато области удобно использовать, если элементов в гриде немного и точно известно, как они должны располагаться. Подробнее о грид-областях рассказано в спецификации. А ещё вы можете потренироваться использовать их, пройдя часть «Знакомство с гридами».

Итак, зададим имена областей описанию и дисклеймеру.


Урок 17.

Свойство align-self в гриде
Мы расположили элементы по сетке. Но для соответствия макету ещё следует поправить выравнивание.

Нам нужно, чтобы блок с ценой не тянулся на всю высоту ряда, а прижимался к верхней границе. Кроме того, дисклеймер следует прижать к нижнему краю карточки.

Макет карточки
В прошлой части для выравнивания элементов по вертикали мы использовали свойство align-items. Оно управляет выравниванием всех элементов в контейнере. Но в нашем случае это свойство не подойдёт, так как у разных элементов должно быть разное выравнивание.

Поэтому используем свойство align-self, оно задаёт выравнивание по вертикали одному элементу. Мы уже встречались с ним, когда работали с флексами. Свойство align-self принимает те же значения, что и align-items: stretch (значение по умолчанию), start, end и center.

.element {
  align-self: start;
}
Используем align-self, чтобы прижать блок с ценой к верхней границе, а дисклеймер — к нижней. После этого добавим на страницу ещё одну карточку и посмотрим, что будет с вёрсткой, если у компонента окажется другое содержимое.

Урок 18.

Изменяем ширину колонок
Мы добавили на страницу вторую карточку. Блок с ценой в ней оказался шире третьей колонки, и в результате содержимое выпало из контейнера. Чтобы более высокая цена не вываливалась, нужно увеличить ширину колонки.

Для этого придётся изменить шаблон карточки: увеличить ширину третьей колонки и уменьшить ширину второй. Но какие размеры им задать? Попробуем сделать колонки одинаковыми по ширине. В этом случае места хватит и для заголовка, и для достаточно большой цены. Вот так карточка будет выглядеть, если увеличить цену до миллиона рублей:

Макет карточки
Разумеется, если цена дойдёт до 10 миллионов, ширину колонок снова придётся менять. Но для мобильного тарифа это маловероятно.

Работая с макетом, нужно помнить, что даже самый дотошный дизайнер не изобразит на нём все возможные состояния компонента. Верстальщик, приступая к работе, должен проанализировать макет, подумать, как будет меняться содержимое компонета, и учесть это в своей вёрстке.

Итак, изменим ширину колонок и посмотрим, как поведут себя блоки с ценой.

урок 20.

Свойство justify-self
Мы увеличили ширину третьей колонки, и цена во второй карточке перестала выпадать. Но при этом блок с ценой (особенно в первой карточке) стал слишком большим. Так произошло, потому что по умолчанию грид-элементы занимают всё доступное пространство не только по высоте, но и по ширине.

Нам нужно, чтобы блоки с низкой ценой не тянулись на всю ширину области, а занимали столько места, сколько требуется их содержимому. Для этого элементу следует задать выравнивание по горизонтали.

Макет карточки
За выравнивание отдельного элемента по горизонтали отвечает свойство justify-self:

.element {
  justify-self: start;
}
Это свойство принимает следующие значения:

stretch — значение по умолчанию; элемент занимает всё пространство по ширине.
start — элемент сжимается до содержимого и прижимается к левой границе.
end — элемент сжимается до содержимого и прижимается к правой границе.
center — элемент сжимается до содержимого и располагается по центру.
Потренируемся использовать свойство justify-self, а затем скажем блоку с ценой прижаться к правому краю.

Свойство justify-self не работает во флексбоксе, поэтому задать выравнивание по главной оси только для одного элемента не получится. В этом случае, как правило, элемент выравнивают с помощью внешних отступов.

Урок 22 КОНСПЕКТ

Конспект «Микросетки. Продолжение». Раздел 2
Придумать подходящую структуру грид-контейнера бывает непросто. Если элементы расположены асимметрично, часто требуется больше колонок, чем кажется на первый взгляд.

Грид-области
Грид-областью называют часть сетки грид-контейнера, у которой есть имя. Имя области придумывает сам разработчик. Оно должно начинаться с буквы и может включать цифры, дефис и знак подчёркивания. Например: header, section-2, user_avatar. Следует выбирать такие имена, которые описывают содержимое области.

Чтобы описать структуру грида с помощью областей, используют свойство grid-template-areas. В нём указывают имена грид-областей. При этом каждый ряд оборачивают в кавычки, а колонки разделяют пробелом.

.card {
  display: grid;
  grid-template-areas: "title price";
}
В grid-template-areas можно указать сколько угодно рядов. При этом в кавычки оборачивают каждый ряд, но точка с запятой ставится только после последнего ряда! Для большей наглядности ряды записывают друг под другом:

grid-template-areas: "title price"
                     "options description";
Однако просто описать шаблон недостаточно, ведь браузер не знает, какие элементы мы имеем в виду. Чтобы связать имя области с соответствующим грид-элементом, используют свойство grid-area. Обратите внимание, в grid-area кавычки не нужны!

.title {
  grid-area: title;
}
Как растянуть грид-область
Если требуется растянуть область на несколько колонок, её имя повторяют нужное число раз:

grid-template-areas: "title title price";
Чтобы растянуть область на несколько рядов, достаточно повторить её имя в разных рядах:

grid-template-areas: "options description"
                     "options disclaimer";
Ограничения при использовании грид-областей
Грид-области должны быть прямоугольными и непрерывными.

// Такой код не сработает
grid-template-areas: "logo main"
                     "main main";

// Такой – тоже
grid-template-areas: "nav logo nav";
При описании шаблона количество колонок в каждом ряду должно быть одинаковым:

// Такой код не сработает
grid-template-areas: "logo nav"
                     "aside main banner"
                     "footer";
Если задать неправильное значение grid-template-areas, браузер его проигнорирует, и вёрстка может сломаться.

Имена областей в одном контейнере должны быть уникальными. Если задать одинаковое имя нескольким элементам, они наложатся друг на друга. По этой причине грид-области не подойдут, например, для списка карточек, особенно если количество этих карточек неизвестно заранее.

Свойство align-self (грид)
Свойство align-self задаёт выравнивание по вертикали одному элементу. Значения align-self принимает те же, что и align-items: stretch (значение по умолчанию), start, end и center.

.element {
  align-self: start;
}
Свойство justify-self
Свойство justify-self отвечает за выравнивание отдельного элемента по горизонтали:

.element {
  justify-self: start;
}
Это свойство принимает следующие значения:

stretch — значение по умолчанию; элемент занимает всё пространство по ширине.
start — элемент сжимается до содержимого и прижимается к левой границе.
end — элемент сжимается до содержимого и прижимается к правой границе.
center — элемент сжимается до содержимого и располагается по центру.

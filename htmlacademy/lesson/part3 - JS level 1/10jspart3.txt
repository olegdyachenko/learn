Курс 3. Знакомство с JavaScript. Часть 2: Коллекции и свойства элементов

Урок 1.
Урок 2.

Метод querySelectorAll и коллекция
Мы выяснили, что попап появляется при клике на первую кнопку, но при клике на вторую ничего не происходит. Закрывается попап нормально, но вот самой подсказки в нём нет. Давайте разбираться!

Почему не работает вторая кнопка? Всё дело в том, что метод querySelector возвращает, то есть передаёт информацию, только об одном элементе. Если в скобках указан селектор, который подходит нескольким элементам на странице, то возвращается только первый из них. Как быть, если нужно найти все элементы? Используем метод querySelectorAll:

// Найдёт все абзацы на странице
let elements = document.querySelectorAll('p');
Метод querySelectorAll находит все элементы на странице, которые соответствуют указанному селектору, и возвращает набор этих элементов — коллекцию.

Коллекцию, как и обычный элемент, можно сохранить в переменной. Самый простой способ узнать, какие элементы содержит коллекция, — вывести её в консоль:

// Выведет коллекцию в консоль
console.log(elements);
В нашей консоли коллекция выглядит как список, в котором элементы перечислены через запятую. Весь список обёрнут в квадратные скобки, а у элементов указан только их тег и, например, класс:

[p.card__text, p, p] 
Чтобы элементы отобразились так же, как в разметке, коллекцию нужно развернуть, кликнув на стрелку-треугольник слева:

[p.card__text, p, p] 
<p class="card__text">Готовим мороженое!</p> 
<p>Санкт-Петербург</p> 
<p>mail@htmlacademy.ru</p> 
Слова-кнопки на нашем сайте — это элементы с классом tooltip-button. Скажем JavaScript найти их все и выведем полученную коллекцию в консоль.

Урок 3.  

Обращаемся к элементам коллекции по индексу
Мы получили коллекцию из двух элементов и вывели её в консоль. Найденные элементы — это кнопки, и по клику на каждую из них должен появляться попап с подсказкой. Для этого каждой кнопке в коллекции нужно добавить обработчик событий. Как сказать JavaScript, что мы хотим сделать что-то с элементом коллекции? Можно обратиться к этому элементу с помощью индекса.

Индекс — это порядковый номер элемента в коллекции. Обратите внимание, отсчёт начинается с нуля, поэтому у первого элемента индекс 0, а у второго — 1. Индексы пишут в квадратных скобках после имени коллекции:

коллекция[индекс]
Обращение к элементам по индексу похоже на обращение к переменным по имени:

let elements = document.querySelectorAll('p');

console.log(elements[0]); // Выведет первый элемент коллекции
console.log(elements[1]); // Выведет второй элемент коллекции
Потренируемся: выведем в консоль сначала первую найденную кнопку, а затем вторую.


Урок 4.


Урок 5. 

Получаем значение data-атрибута
Мы научились работать с элементами в коллекции и сделали так, чтобы попап появлялся при клике на любую из кнопок. Внутри попапа должен выводиться текст, поясняющий слово, на которое нажал пользователь. Текст подсказки хранится в разметке, в атрибуте data-tooltip-text самой кнопки.

Что это за атрибут? HTML — гибкий язык, и в нём можно создавать свои собственные атрибуты. Имена таких атрибутов начинаются с префикса data-, после которого идёт любое выбранное разработчиком слово. Это немного похоже на переменные: вы сами решаете, как назвать атрибут и какое он должен иметь значение.

Например:

<div data-cat-name="Кекс">
Атрибуты, начинающиеся с data-, обычно используют, чтобы хранить вспомогательную информацию. Подробнее о них вы можете почитать здесь.

Как получить значение такого атрибута в JavaScript? Для этого используют свойство dataset, после которого указывают имя атрибута без префикса data-:

элемент.dataset.имяАтрибутаБезПрефикса
Если имя атрибута состояло из нескольких слов и в нём были дефисы, то в JavaScript его записывают в «верблюжьем» стиле (по-английски camelCase): дефисы убирают, а каждое слово, кроме первого, пишут с большой буквы. Чтобы получить значение атрибута из примера выше, нужно использовать такие инструкции:

let element = document.querySelector('div');
console.log(element.dataset.catName); // Выведет: Кекс
На нашем сайте тексты подсказок хранятся в атрибутах data-tooltip-text. Посмотрим, как они выглядят в разметке, а после выведем в консоль значение этого атрибута каждой кнопки.

Собственные атрибуты можно создавать и без префикса data-, но такой код не будет соответствовать стандарту, или спецификации. В таком случае говорят, что код невалидный. Проверить код на валидность можно с помощью валидатора.

Подробнее о валидности и валидаторе можно почитать в этой статье.

https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes
https://validator.w3.org/nu/
https://htmlacademy.ru/blog/boost/tutorial/html-validation


Урок 6. 


Выводим текст подсказки на страницу
Мы познакомились с data-атрибутами и вывели в консоль значение атрибута data-tooltip-text обеих кнопок. Этот атрибут нам нужен, чтобы показать правильную подсказку. Если пользователь нажал на первую кнопку, то внутри попапа должен появиться текст из атрибута первой кнопки, а если на вторую — то второй.

Выводить текст будем в элементе с классом tooltip-text. В разметке он находится внутри попапа:

<div class="tooltip">
  <span class="tooltip-text"></span>
  <button class="button close-button" type="button">
    <span>Закрыть</span>
  </button>
</div>
Найдём этот элемент, сохраним в переменную и будем изменять его текстовое содержимое. Внутри первого обработчика событий используем текст из атрибута первой кнопки, а внутри второго — второй. Кликнем на обе кнопки и проверим, что в попапе выводится правильный текст подсказки.
В этот момент Кекс пробежал по клавиатуре (наверное, куда-то торопился и решил срезать), и из файла пропали все выводы в консоль.


Урок 7. 
Урок 8. 


Цикл for of
Мы подключили наш скрипт к другой новости, в которой оказалось четыре кнопки. Мы кликнули на них, но сработали только первые две, ведь обработчики мы добавили только им. Как быть? Неужели придётся создавать отдельный скрипт для каждой новости и копировать обработчики? Конечно, нет. Используем цикл.

Цикл — это конструкция, которая позволяет выполнить код несколько раз. В JavaScript существуют разные циклы, мы познакомимся с ними в следующих частях. Для нашей же задачи используем цикл for of:

for (переменная of коллекция) {
  // Код, который нужно выполнить несколько раз
}
Цикл for of выполнит код из фигурных скобок столько раз, сколько элементов содержится в коллекции, указанной в круглых скобках. Каждое такое повторение называется итерацией.

При создании цикла в круглых скобках также нужно указать переменную. Обычно для этого объявляют новую переменную и используют её только внутри цикла. На каждой итерации JavaScript будет автоматически записывать в эту переменную очередной элемент коллекции.

Рассмотрим пример:

let elements = document.querySelectorAll('p'); // Находим все абзацы

for (let element of elements) {  // Создаём цикл и переменную
  console.log(element);          // Выводим элементы в консоль
}
Если в коллекции elements два элемента, то JavaScript выполнит следующие инструкции:

// Первая итерация:
// В переменную автоматически записывается первый элемент коллекции
element = elements[0];
// Выполняется код из цикла – первый элемент коллекции выводится в консоль
console.log(element);

// Вторая итерация:
// В переменную автоматически записывается второй элемент коллекции
element = elements[1];
// Повторяется код из цикла, но теперь в консоль выводится второй элемент
console.log(element);
Цикл завершится, когда в коллекции закончатся элементы. После этого JavaScript перейдёт к инструкциям, которые идут после цикла.

Благодаря циклу нам не нужно заранее знать количество элементов в коллекции


Урок 9. 


Добавляем обработчик с помощью цикла
Мы использовали цикл for of, чтобы вывести в консоль все элементы коллекции. Таким же образом мы можем добавить обработчик кликов всем кнопкам в новости. Воспользуемся циклом: на каждой итерации будем добавлять обработчик элементу, который сейчас находится в переменной цикла. В результате мы получим универсальный скрипт — обработчик добавится каждому элементу в коллекции, сколько бы их ни было.

Например:

let elements = document.querySelectorAll('p');

for (let element of elements) {
  // Добавляем обработчик всем элементам по очереди
  element.onclick = function () {
    console.log('Вы кликнули на абзац!');
  };
}
Когда цикл из примера выполнится, обработчики добавятся всем абзацам в коллекции elements, и при клике на каждый из них будет выводиться сообщение в консоль.

Обработчик событий, благодаря которому показываются подсказки на новостном сайте, уже написан. Перенесём его внутрь цикла и заменим обращение по индексу на переменную tooltipButton, которую мы используем в цикле.

// До:
tooltipButtons[0].onclick = function () {
  ...
};

// После:
for (let tooltipButton of tooltipButtons) {
  tooltipButton.onclick = function () {
    ...
  };
}
Обработчик, который мы добавляли второй кнопке, удалим, он больше не нужен. После этого убедимся, что при клике на каждую кнопку появляется попап с подсказкой.


Урок 10. 


Обработчик событий oninput
Мяу! Люди слишком много болтают, комментарии не должны быть длиннее самой новости!

А вот и новая задача от босса. Система комментирования, которую мы создали в предыдущей части, оказалась очень удобной, пользователи охотно обсуждают новости… и иногда увлекаются. Босс хочет, чтобы комментарии на сайте были не длиннее 142 символов. Верстальщик добавил в форму комментирования счётчик, чтобы пользователи видели, сколько символов они уже использовали. Если лимит символов превышен, то кнопка отправки комментария должна блокироваться, а счётчик символов и текст в поле ввода становиться красными.

Придётся доработать наш скрипт!

Мы уже умеем получать данные из поля ввода, но только после того, как форма была отправлена. Сейчас же нам нужно оценить длину комментария ещё до отправки. Как быть? Воспользуемся обработчиком событий oninput (в переводе с английского это означает «при вводе»). Инструкции внутри обработчика oninput выполняются каждый раз, когда значение в поле ввода меняется. Например:

// Найдём поле ввода
let textarea = document.querySelector('textarea');

// Добавим обработчик событий
textarea.oninput = function () {
  // Выведем данные из поля ввода
  console.log(textarea.value);
};
Наберём слово «Кекс», потом удалим последний символ и заглянем в консоль:

К (String)
Ке (String)
Кек (String)
Кекс (String)
Кек (String)
Обратите внимание, текст из поля ввода выводился в консоль при каждом изменении: и когда добавляли новый символ, и когда символ удаляли.

Благодаря обработчику событий oninput мы можем получить текст комментария ещё до того, как пользователь его отправит. Посмотрим, как это работает: добавим обработчик полю ввода комментария и введём какой-нибудь текст.


Урок 11. 

Свойство length, вычисляем длину строки
Мы познакомились с обработчиком событий oninput и получили данные из поля ввода без отправки формы. Босс хочет, чтобы комментарии были не длиннее 142 символов и чтобы пользователи видели, сколько символов они уже использовали. Для этого нам нужно вычислить длину комментария и вывести её на страницу.

Узнать длину комментария нам поможет свойство length (по-английски «длина»). Значение этого свойства равно числу символов в строке. Символами считаются не только буквы и цифры, но также пробелы и переносы строки.

let text = 'Я люблю JavaScript';
console.log(text.length); // Выведет: 18

let textarea = document.querySelector('textarea');
console.log(textarea.value); // Выведет: Кекс
console.log(textarea.value.length); // Выведет: 4
Пользователи новостного сайта должны видеть, какой длины набранный ими текст. Чтобы вывести длину на страницу, изменим текстовое содержимое элемента с классом char-counter. Этот элемент находится прямо под полем ввода:

<span class="text-counter">
  Использовано <output class="char-counter">0</output>/142 символов
</span>
Счётчик символов должен реагировать на каждое изменение в поле ввода, поэтому менять текстовое содержимое элемента мы будем внутри нашего обработчика oninput. Чтобы убедиться, что счётчик символов работает, начнём набирать новый комментарий.


Урок 12. 

Закрыть
Сравниваем числа
Отлично, теперь счётчик символов показывает длину нового комментария! Если комментарий длиннее 142 символов, должен появиться сигнал об ошибке: счётчик символов и текст в поле ввода должны стать красными. Чтобы сигнал появился, форме комментирования нужно добавить класс warning. С этой формой мы уже работали в предыдущей части, она сохранена в переменной commentForm.

Сигнал об ошибке должен появляться, только если новый комментарий слишком длинный. Слово «если» в задаче — верный признак того, что понадобится условная конструкция. Мы познакомились с конструкцией if в этом задании.

Чтобы определить, не превышен ли лимит символов, сравним длину комментария с числом 142. Для этого используем оператор сравнения > («больше»). Он сравнивает два числа и возвращает булево значение: true, если левое число больше правого, и false во всех остальных случаях. Например:

console.log(3 > 2); // Вернёт: true
console.log(1 > 2); // Вернёт: false
console.log(2 > 2); // Вернёт: false
Чтобы проверить, подходит ли новый комментарий по длине, добавим в наш скрипт условную конструкцию: сравним длину текста из поля ввода с числом 142 и, если длина больше, добавим форме класс warning. После этого протестируем, как работает проверка, и попробуем отправить слишком длинный комментарий.

Урок 13. 

Свойство disabled, блокируем кнопку
Мы добавили условную конструкцию в наш скрипт, и теперь, если новый комментарий длиннее 142 символов, появляется сигнал об ошибке. Но это не мешает отправить форму и опубликовать слишком длинный комментарий. Чтобы это исправить, нужно не только добавлять класс форме, но и блокировать кнопку отправки. Если кнопка заблокирована, форму отправить не получится.

Блокировать и разблокировать кнопку в JavaScript можно, присваивая булевы значения свойству disabled (по-английски значит «отключён») этой кнопки. Если присвоено значение true, то кнопка заблокирована, а если false — разблокирована.

let button = document.querySelector('button');

// Блокирует кнопку
button.disabled = true;

// Разблокирует кнопку
button.disabled = false;
За отправку нового комментария на нашем сайте отвечает кнопка с классом submit-button. Найдём её и сохраним в переменную. После этого дополним условную конструкцию: если комментарий слишком длинный, кнопка отправки должна блокироваться. Проверим, как теперь работает форма.


Урок 14. 

Закрыть
Добавляем ветку else
Задание босса почти выполнено: пользователи больше не могут публиковать слишком длинные комментарии. Если текст в поле ввода длиннее 142 символов, кнопка отправки блокируется и появляется сигнал об ошибке. В этом случае пользователь должен поправить комментарий. Сейчас сигнал об ошибке не исчезает, а кнопка отправки не разблокируется, даже если укоротить текст до нужной длины. Как это исправить?

Нам нужна альтернативная ветка else: если условие ложно, то есть комментарий не длиннее 142 символов, то в свойство disabled кнопки нужно записать false, а класс warning у формы убрать.

Добавим в наш скрипт вторую ветку и необходимые инструкции и проверим, что теперь всё работает как надо: если комментарий слишком длинный, кнопка блокируется и появляется сигнал об ошибке, а если лимит символов не превышен, то кнопка разблокируется и сигнал об ошибке пропадает.

Урок 15. 

Обнуляем счётчик символов
Проверка нового комментария отлично работает: если текст в поле ввода длиннее 142 символов, то появляется сигнал об ошибке и отправка комментария блокируется, а если текст сократить, то блокировка снимается и сигнал исчезает. Вот только счётчик символов после отправки комментария не обнуляется.

Это происходит потому, что обработчик oninput не срабатывает, когда мы отправляем форму и очищаем поле ввода. Чтобы комментарии заработали как надо, присвоим текстовому содержимому счётчика значение 0 внутри другого обработчика событий — onsubmit. Он уже есть в нашем скрипте, мы работали с ним в предыдущей части. Инструкции внутри этого обработчика выполняются в момент отправки формы, так что, когда пользователь отправит новый комментарий, счётчик обнулится. Убедимся в этом!

charCounter.textContent = 0;



Урок 16. КОНСПЕКТ


Конспект «Коллекции и свойства элементов»
Метод querySelectorAll
Метод querySelectorAll находит все элементы на странице, которые соответствуют указанному селектору, и возвращает коллекцию — набор этих элементов.

// Найдёт все абзацы на странице
let elements = document.querySelectorAll('p');
Коллекция
Коллекцию можно сохранить в переменной. Самый простой способ узнать, какие элементы содержит коллекция, — вывести её в консоль:

// Выведет коллекцию в консоль
console.log(elements);
В консоли коллекция выглядит как список, в котором элементы перечислены через запятую. Весь список обёрнут в квадратные скобки, а у элементов указан только их тег и, например, класс. Чтобы элементы отобразились так же, как в разметке, коллекцию нужно развернуть, кликнув на стрелку-треугольник слева.

[p.card__text, p, p] 
<p class="card__text">Готовим мороженое!</p> 
<p>Санкт-Петербург</p> 
<p>mail@htmlacademy.ru</p> 
К элементу коллекции можно обращаться по индексу. Индекс — это порядковый номер элемента в коллекции. Отсчёт начинается с нуля, поэтому у первого элемента индекс 0, а у второго — 1. Индексы пишут в квадратных скобках после имени коллекции:

console.log(elements[0]); // Выведет первый элемент коллекции
console.log(elements[1]); // Выведет второй элемент коллекции
Data-атрибуты
В HTML можно создавать свои собственные атрибуты. Имена таких атрибутов начинаются с префикса data-, после которого идёт любое выбранное разработчиком слово.

<div data-cat-name="Кекс">
Чтобы получить значение data-атрибута в JavaScript, используют свойство dataset, после которого указывают имя атрибута без префикса data-:

элемент.dataset.имяАтрибутаБезПрефикса
Если имя атрибута состояло из нескольких слов и в нём были дефисы, то в JavaScript его записывают в «верблюжьем» стиле (по-английски camelCase): дефисы убирают, а каждое слово, кроме первого, пишут с большой буквы.

let element = document.querySelector('div');
console.log(element.dataset.catName); // Выведет: Кекс
Цикл for of
Цикл — это конструкция, которая позволяет выполнить код несколько раз. Цикл for of выполнит код из фигурных скобок столько раз, сколько элементов содержится в коллекции, указанной в круглых скобках. Каждое такое повторение называется итерацией.

for (переменная of коллекция) {
  // Код, который нужно выполнить несколько раз
}
При создании цикла в круглых скобках также нужно указать переменную. Обычно для этого объявляют новую переменную и используют её только внутри цикла. На каждой итерации JavaScript будет автоматически записывать в эту переменную очередной элемент коллекции.

let elements = document.querySelectorAll('p'); // Находим все абзацы

for (let element of elements) {  // Создаём цикл и переменную
  console.log(element);          // Выводим элементы в консоль
}
Цикл for of завершится, когда в коллекции закончатся элементы. После этого JavaScript перейдёт к инструкциям, которые идут после цикла.

Обработчик событий oninput
Обработчик событий oninput (в переводе с английского это означает «при вводе») позволяет выполнять инструкции из фигурных скобок каждый раз, когда меняется значение в поле ввода. Изменением считается и добавление, и удаление символов.

// Найдём поле ввода
let textarea = document.querySelector('textarea');

// Добавим обработчик событий
textarea.oninput = function () {
  // Выведем данные из поля ввода
  console.log(textarea.value);
};
Свойство length
Узнать длину строки можно с помощью свойства length (по-английски «длина»). Значение этого свойства равно числу символов в строке. Символами считаются не только буквы и цифры, но также пробелы и переносы строки.

let text = 'Я люблю JavaScript';
console.log(text.length); // Выведет: 18

let textarea = document.querySelector('textarea');
console.log(textarea.value); // Выведет: Кекс
console.log(textarea.value.length); // Выведет: 4
Оператор сравнения >
Оператор сравнения > («больше») сравнивает два числа и возвращает булево значение: true, если левое число больше правого, и false во всех остальных случаях:

console.log(3 > 2); // Вернёт: true
console.log(1 > 2); // Вернёт: false
console.log(2 > 2); // Вернёт: false
Свойство disabled
Блокировать и разблокировать кнопку в JavaScript можно, присваивая булевы значения свойству disabled (по-английски значит «отключён») этой кнопки. Если присвоено значение true, то кнопка заблокирована, а если false — разблокирована.

let button = document.querySelector('button');

// Блокирует кнопку
button.disabled = true;

// Разблокирует кнопку
button.disabled = false;


Урок 17. Испытание. 

Интересное задание. Клавиатура, текст и так мало строк кода, чтобы все это оживить. Офигенно

let keyAll = document.querySelectorAll('.key');
let display = document.querySelector('.display');
let clear = document.querySelector('.clear');

for (let key of keyAll){
    key.onclick = function(){
      display.append(key.textContent);
    }
    
}

clear.onclick = function(){display.textContent = "";}


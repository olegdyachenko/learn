Курс 1. Знакомство с веб-разработкой. Часть 2: Основы JavaScript



вот так подключаем - <script src="адрес_файла"></script>


<body>
  <!-- Содержимое страницы -->

  <script src="app.js"></script>
</body>




document.querySelector('селектор'); - элемент, метод(селектор);
Обратите внимание, эта инструкция состоит из двух частей. Первая часть — это элемент, внутри которого будет искать JavaScript. Словом document обозначается веб-страница, к которой подключили скрипт. Неважно, как называется файл на самом деле, в JavaScript это всегда «документ». Он является элементом-родителем для любого другого элемента на странице.

Вторая часть инструкции — это то, что нужно сделать. Её называют методом. Метод querySelector ищет по селектору, который указан в скобках. Не знаете, что такое селектор? Тогда вам стоит заглянуть в «Основы CSS», там всему научат.

Чтобы сказать JavaScript, что инструкция закончена, нужно поставить точку с запятой или перейти на новую строку. Новая строка правильно работает в большинстве случаев, а точка с запятой — всегда. Поэтому лучше ставить точку с запятой в конце каждой инструкции.

Итак, чтобы найти на странице элемент с классом page, мы должны написать:

document.querySelector('.page');




console.log('Привет от JavaScript!');




элемент.classList.remove('класс');
Метод убирает с элемента тот класс, который указан в скобках. Обратите внимание, что мы не ставим точку перед именем класса в classList.remove. Это не селектор, JavaScript и так знает, что мы имеем дело с классом.

Обратите внимание, что буква «L» в названии метода заглавная. JavaScript чувствителен к регистру. Если написать classlist.remove, метод не сработает.


document.querySelector('.page').classList.remove('light-theme');






document.querySelector('.page').classList.add('dark-theme') - добавляет 

При этом, если вы заглянете в index.html, то увидите, что ничего не изменилось: класс light-theme по-прежнему на месте, а dark-theme отсутствует. Почему так? Дело в том, что скрипт не меняет исходный файл с разметкой, но, выполняя инструкции, меняет страницу прямо в браузере пользователя.




Переменная — это способ сохранить данные, дав им понятное название.

В JavaScript переменную можно создать, или, как говорят программисты, объявить, с помощью ключевого слова let. За ним следует имя переменной. После объявления в переменную нужно записать, или присвоить, какое-то значение:

let variableName = 'Я значение переменной!';



Имя переменной может быть почти любым, но не должно начинаться с цифры, а из спецсимволов разрешены только '_' и '$'. Кроме того, в JavaScript есть зарезервированные слова(https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#Ключевые_слова), которые нельзя использовать для именования переменных. Имена переменных чувствительны к регистру: header, Header и HEADER — это разные переменные. Но самое главное — чтобы переменная действительно делала код понятнее, её имя должно описывать то, что в ней хранится.

Сохранять в переменные можно что угодно, в том числе элементы:

let header = document.querySelector('header');


Когда в коде встречается переменная, браузер вместо её имени подставляет присвоенное ей значение. Благодаря этому мы можем написать, например, так:


console.log(header);
header.classList.add('new-class');
Обратите внимание, что let мы пишем только при объявлении переменной. После этого мы используем переменную, просто указывая её имя.



Ключевое слово let появилось в JavaScript в 2015 году, до этого для объявления переменных использовалось слово var. Оно работает почти так же, как let, но есть некоторые отличия. О них мы расскажем в следующих частях.



Сначала мы находим саму кнопку и сохраняем её в переменную:

let button = document.querySelector('button');
После того, как кнопка была найдена, мы указываем JavaScript, что делать, когда по этой кнопке кликнут. Это может быть, например, вывод сообщения в консоль:

button.onclick = function() {
  console.log('Клик!');
};
Инструкции, которые выполняются после клика по кнопке, располагаются внутри фигурных скобок.


Клик по кнопке, с точки зрения браузера, это событие. Свойство onclick означает «по клику» и говорит JavaScript, какое событие мы хотим отслеживать. А та часть инструкции, которая идёт после onclick, называется обработчиком событий.


В JavaScript есть и другой способ создать обработчик событий. Мы поговорим о нём в следующих частях, но, если вам любопытно, можете почитать о нём в документации по JavaScript. (https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener)






Так как заставить темы переключаться при каждом клике? Веб-разработчикам часто приходится решать подобные задачи, и создатели JavaScript позаботились, чтобы чередовать классы можно было легко и удобно с помощью метода classList.toggle:

элемент.classList.toggle('класс');
Если класс у элемента есть, метод classList.toggle ведёт себя как classList.remove и класс у элемента убирает. А если указанного класса у элемента нет, то classList.toggle, как и classList.add, добавляет элементу этот класс.

Используем метод-переключатель classList.toggle и убедимся, что при нажатии на кнопку «Изменить тему» у элемента будет то убираться, то добавляться класс light-theme.




Мы написали инструкцию, которая убирает у элемента класс light-theme, если он есть, и добавляет, если его нет. Благодаря этому при клике по кнопке «Изменить тему» светлая тема на странице то выключается, то включается. Но что насчёт тёмной темы? Нам ведь нужно, чтобы темы переключались. Для этого надо, чтобы у элемента page чередовались классы light-theme и dark-theme: сначала добавлялся один и удалялся другой, а потом наоборот. Как это сделать?

Нужно написать вторую инструкцию с classList.toggle. Она будет то добавлять, то удалять класс dark-theme при клике. Чтобы темы переключались, инструкции должны работать в противофазе. Для этого в исходной разметке у элемента page должен быть указан один класс темы, а второй нет. Тогда один класс удалится, а другой, наоборот, добавится к элементу.


Когда пользователь кликнет по кнопке второй раз, первая инструкция добавит класс light-theme, а вторая — удалит класс dark-theme. Нечётные клики будут делать то же, что и первый клик, а чётные — то же, что и второй. Пользователь сможет переключить тему столько раз, сколько пожелает.



Верстальщик для этого выделил элемент с классом subscription-message. Сейчас в нём уже есть текст: «Обещаем присылать вам новости не чаще одного раза в день, причём только самые интересные и важные». Когда пользователь отправит форму, вместо этого текста должно появиться сообщение об удачной подписке. Получается, нам нужно найти элемент, удалить из него старый текст, а после вставить новый. 

У каждого элемента имеется множество свойств: его размеры, цвет и так далее. Свойство textContent хранит в себе текстовое содержимое элемента.


let paragraph = document.querySelector('p');
console.log(paragraph.textContent);
В результате в консоли появится сообщение Я текст!


Возьмем текст со страницы
И перезапишем его текстовое содержимое:

let paragraph = document.querySelector('p');
paragraph.textContent = 'Здесь был Кекс. Мяу!';

Свойство textContent предназначено только для текста, если записать туда HTML-теги, браузер их не поймёт.

message.textContent = 'Какой <strong>непонятливый</strong> браузер!';

Теги html не применяются. Просто как текст воспринимаются





В HTML кнопка отправки имеет тип submit, а в JavaScript за обработку этого события отвечает свойство onsubmit. Обратите внимание, обработчик событий в данном случае добавляется не на кнопку, а на саму форму:

let someForm = document.querySelector('.some-form');
someForm.onsubmit = function() {
  console.log('Форма отправлена!');
};


В JavaScript есть два вида комментариев:

// Однострочные комментарии.

/*
И многострочные.
Они могут отключить сразу несколько строк кода.
*/





let form = document.querySelector('.subscription');
form.onsubmit = function(evt) {
  // Инструкция ниже отменяет отправку данных
  evt.preventDefault();
  message.textContent = 'Форма отправлена!';

};





Адрес электронной почты в сообщении должен быть тем, который введёт пользователь. Как его получить?

Нам поможет особое свойство, которое есть у полей ввода, — value. Допустим, на странице есть поле ввода input:


<input type="text">


С помощью свойства value мы можем получить данные из этого поля ввода. А после, например, вывести их в консоль:

let input = document.querySelector('input');
console.log(input.value);
// Выведет: Кекс


А ещё мы можем вывести данные из поля ввода прямо на страницу. Представим, что у нас на странице есть абзац, который мы нашли и сохранили в переменную paragraph. Мы можем сделать так:

paragraph.textContent = input.value;

И теперь то, что ввёл пользователь в поле input, отобразится на странице как текстовое содержимое элемента paragraph.

Почему бы не прочитать текст из поля ввода с помощью textContent? Если мы попытаемся это сделать, то получим пустую строку. Для JavaScript поля формы не имеют текстового содержимого, их значения хранятся именно в value.




Нам нужно «склеить» несколько значений. Операция, которая позволяет присоединить одно значение к другому, называется конкатенацией и в JavaScript выполняется с помощью знака плюс.






Склеивать можно обычные строки:

paragraph.textContent = 'Вас зовут ' + 'инструктор Кекс';
console.log(paragraph.textContent);
// Выведет: Вас зовут инструктор Кекс
А можно — строки и переменные (или свойства элементов). И, кстати, значений может быть больше двух:

let name = 'Кекс';
paragraph.textContent = 'Вас зовут ' + name + '. Хорошего дня!';
console.log(paragraph.textContent);
// Выведет: Вас зовут Кекс. Хорошего дня!
Сообщение об удачной подписке состоит из двух строк и свойства email.value:

'Адрес ' + email.value + ' добавлен в список получателей рассылки.'
Скажем JavaScript выводить его после отправки формы — и страница с подпиской готова! Кекс, принимай работу!